---
layout: notebook
title: Hand-Eye Calibration Problem
description: Hand-eye Calibration
tag: Notebook
---

<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h2 id="Frame-Definitions-and-Observed-Points">
    Frame Definitions and Observed Points
    <a class="anchor-link" href="#Frame-Definitions-and-Observed-Points">
     ¶
    </a>
   </h2>
   <p>
    In the hand-eye calibration problem, we define the following coordinate frames:
   </p>
   <ul>
    <li>
     <strong>
      Base Frame
     </strong>
     : The fixed coordinate frame of the robot arm, denoted as $ \mathbf{B} $
    </li>
    <li>
     <strong>
      End-Effector Frame
     </strong>
     : The frame attached to the robot's end-effector, denoted as $ \mathbf{E} $
    </li>
    <li>
     <strong>
      Camera Frame
     </strong>
     : The coordinate frame of the camera, which is rigidly mounted to the end-effector, denoted as $ \mathbf{C} $
    </li>
    <li>
     <strong>
      World Frame
     </strong>
     : A global reference frame in which known points are defined, denoted as $ \mathbf{W} $
    </li>
   </ul>
   <p>
    We assume that four known points are in the world frame:
   </p>
   <p>
    $$
p_W = \begin{bmatrix}
-1 &amp; -1 &amp; 0 \\
-1 &amp; 1 &amp; 0\\
1 &amp; -1 &amp; 0\\
1 &amp; 1 &amp; 0
\end{bmatrix}
$$
   </p>
   <p>
    where each row represents the ((x, y, z)) coordinates of a point in the world frame.
   </p>
   <p>
    These points serve as reference points that can be used to estimate the transformation between different coordinate frames.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h2 id="Hand-Eye-Calibration-Goal">
    Hand-Eye Calibration Goal
    <a class="anchor-link" href="#Hand-Eye-Calibration-Goal">
     ¶
    </a>
   </h2>
   <p>
    In the hand-eye calibration problem, our goal is to estimate the transformation between the camera and the end-effector, as well as the camera's intrinsic parameters.
   </p>
   <p>
    We define the transformation from the
    <strong>
     camera frame
    </strong>
    $\mathbf{C}$ to the
    <strong>
     end-effector frame
    </strong>
    $\mathbf{E}$ as: $\mathbf{T}_{EC} \in SE(3)$. This transformation allows us to convert a point $\mathbf{p}_C$ in the camera frame to the end-effector frame using: $\mathbf{p}_E = \mathbf{T}_{EC} \mathbf{p}_C$
   </p>
   <p>
    In addition to the hand-eye transformation, we may also need to estimate the
    <strong>
     camera intrinsics
    </strong>
    , which describe how 3D points in the camera frame are projected onto the image plane. The camera intrinsics matrix is given by
$ \mathbf{K} =
\begin{bmatrix}
f_x &amp; \gamma &amp; c_x \\
0 &amp; f_y &amp; c_y \\
0 &amp; 0 &amp; 1
\end{bmatrix}$.
   </p>
   <p>
    where:
   </p>
   <ul>
    <li>
     $f_x, f_y$ are the focal lengths in pixels,
    </li>
    <li>
     $c_x, c_y$ are the principal point coordinates.
    </li>
    <li>
     $\gamma$ is a skew parameter.
    </li>
   </ul>
   <p>
    Note:
   </p>
   <ul>
    <li>
     In this tutorial, we assume there is no tangent and radial distortion
    </li>
    <li>
     See
     <code>
      Optimal Hand-Eye Calibration
     </code>
     from Klaus H Strobl and Gerd Hirzinger for more details
    </li>
   </ul>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h2 id="Install-packates-(on-Google-Colab)-and-import-packages">
    Install packates (on Google Colab) and import packages
    <a class="anchor-link" href="#Install-packates-(on-Google-Colab)-and-import-packages">
     ¶
    </a>
   </h2>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [ ]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Run this first if you use GoogleColab</span>

<span class="err">!</span><span class="n">pip</span> <span class="n">install</span> <span class="n">pytransform3d</span>

<span class="c1"># You don't need this if you don't want to run factor-graph based opimization.</span>
<span class="err">!</span><span class="n">pip</span> <span class="n">install</span> <span class="n">symforce</span>
<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [14]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Import packages</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pytransform3d</span> <span class="kn">import</span> <span class="n">transformations</span> <span class="k">as</span> <span class="n">pt</span>
<span class="kn">from</span> <span class="nn">pytransform3d</span> <span class="kn">import</span> <span class="n">rotations</span> <span class="k">as</span> <span class="n">pr</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h1 id="Steps-to-Solve-the-Hand-Eye-Calibration-Problem">
    Steps to Solve the Hand-Eye Calibration Problem
    <a class="anchor-link" href="#Steps-to-Solve-the-Hand-Eye-Calibration-Problem">
     ¶
    </a>
   </h1>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h2 id="References:">
    References:
    <a class="anchor-link" href="#References:">
     ¶
    </a>
   </h2>
   <p>
    <code>
     Robot Sensor Calibration: Solving AX = XB on the Euclidean Group
    </code>
    Frank C. Park and Bryan J Martin
   </p>
   <p>
    <code>
     Optimal Hand-Eye Calibration
    </code>
    Klaus H Strobl and Gerd Hirzinger
   </p>
   <p>
    <code>
     A flexible new technique for camera calibration
    </code>
    Zhengyou Zhang
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h2 id="Simulated-Problem-Definition">
    Simulated Problem Definition
    <a class="anchor-link" href="#Simulated-Problem-Definition">
     ¶
    </a>
   </h2>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    To validate the hand-eye calibration method, we define a simulated environment where a camera observes known 3D points in the world. This setup allows us to generate synthetic camera poses and project world points onto the image plane.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Defining-3D-Points-in-the-World-Frame">
    Defining 3D Points in the World Frame
    <a class="anchor-link" href="#Defining-3D-Points-in-the-World-Frame">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    We define four 3D points in the
    <strong>
     world frame
    </strong>
    $\mathbf{W}$ that lie on the $z=0$ plane:
   </p>
   <p>
    $$
\mathbf{p}_W =
\begin{bmatrix}
-1 &amp; -1 &amp; 0 \\
1 &amp; -1 &amp; 0 \\
1 &amp; 1 &amp; 0 \\
-1 &amp; 1 &amp; 0
\end{bmatrix}
$$
   </p>
   <p>
    To work with homogeneous coordinates, we append a row of ones:
   </p>
   <p>
    $$
\tilde{\mathbf{p}}_W =
\begin{bmatrix}
-1 &amp; 1 &amp; 1 &amp; -1 \\
-1 &amp; -1 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Camera-Intrinsic-Matrix">
    Camera Intrinsic Matrix
    <a class="anchor-link" href="#Camera-Intrinsic-Matrix">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    The camera intrinsics matrix $\mathbf{K}$ models how 3D points are projected onto the image plane:
   </p>
   <p>
    $$
\mathbf{K} =
\begin{bmatrix}
f_x &amp; 0 &amp; c_x \\
0 &amp; f_y &amp; c_y \\
0 &amp; 0 &amp; 1
\end{bmatrix}
$$
   </p>
   <p>
    where:
   </p>
   <ul>
    <li>
     $f_x = 800, f_y = 800$ are the focal lengths (in pixels),
    </li>
    <li>
     $c_x = 320, c_y = 240$ are the principal point coordinates.
    </li>
    <li>
     We have $\gamma$ as 0 in this case.
    </li>
   </ul>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Generating-Camera-Poses">
    Generating Camera Poses
    <a class="anchor-link" href="#Generating-Camera-Poses">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    To simulate multiple views, we generate camera poses in spherical coordinates, where:
   </p>
   <ul>
    <li>
     The camera moves along a sphere of varying radii ($r \in [10, 20]$),
    </li>
    <li>
     The
     <strong>
      azimuth angle
     </strong>
     varies from $0^\circ$ to $360^\circ$,
    </li>
    <li>
     The
     <strong>
      elevation angle
     </strong>
     varies from $30^\circ$ to $60^\circ$.
    </li>
   </ul>
   <p>
    For a given azimuth $\theta$ and elevation $\phi$, the camera position in Cartesian coordinates is:
   </p>
   <p>
    $$
\mathbf{t} =
\begin{bmatrix}
r \cos\phi \cos\theta \\
r \cos\phi \sin\theta \\
r \sin\phi
\end{bmatrix}
$$
   </p>
   <p>
    The camera orientation is determined using a
    <strong>
     look-at transformation
    </strong>
    , where:
   </p>
   <ul>
    <li>
     The
     <strong>
      forward vector
     </strong>
     points from the camera to the world origin,
    </li>
    <li>
     The
     <strong>
      right vector
     </strong>
     is computed as the cross-product of the world $z$-axis and the forward vector,
    </li>
    <li>
     The
     <strong>
      up vector
     </strong>
     is computed as the cross-product of the forward and right vectors.
    </li>
   </ul>
   <p>
    The rotation matrix $\mathbf{R}_{WC}$ is then constructed as:
   </p>
   <p>
    $$
\mathbf{R}_{WC} =
\begin{bmatrix}
\mathbf{r} &amp; \mathbf{u} &amp; \mathbf{f}
\end{bmatrix}
$$
   </p>
   <p>
    where $\mathbf{r}, \mathbf{u}, \mathbf{f}$ are the right, up, and forward unit vectors, respectively.
   </p>
   <p>
    The final transformation from the world to the camera frame is:
   </p>
   <p>
    $$
\mathbf{T}_{WC} =
\begin{bmatrix}
\mathbf{R}_{WC} &amp; \mathbf{t} \\
0 &amp; 1
\end{bmatrix}
$$
   </p>
   <p>
    This process generates a set of camera poses that will be used to simulate observations and test the hand-eye calibration process.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [101]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Generate a simulated problem</span>

<span class="c1"># Define the 3D points in the world coordinate system</span>
<span class="n">world_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">homogeneous_world_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">world_points</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">world_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>

<span class="c1"># Define the camera intrinsic matrix (K)</span>
<span class="n">fx</span><span class="p">,</span> <span class="n">fy</span> <span class="o">=</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">800</span>  <span class="c1"># Focal lengths</span>
<span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">240</span>  <span class="c1"># Principal point</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">fx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cx</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">cy</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>


<span class="k">def</span> <span class="nf">generate_camera_poses</span><span class="p">(</span><span class="n">num_r</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_z</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">num_e</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="c1"># def generate_camera_poses(num_r=4, num_z=10, num_e=10):</span>
    <span class="n">camera_poses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num_r</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">azimuth_deg</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num_z</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">elevation_deg</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num_e</span><span class="p">):</span>
                <span class="n">azimuth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">azimuth_deg</span><span class="p">)</span>
                <span class="n">elevation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">elevation_deg</span><span class="p">)</span>

                <span class="c1"># Convert spherical to Cartesian coordinates</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">elevation</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">azimuth</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">elevation</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">azimuth</span><span class="p">)</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">elevation</span><span class="p">)</span>

                <span class="c1"># Camera position</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>

                <span class="c1"># Camera rotation matrix</span>
                <span class="c1"># Note: Camera is looking at its negative z</span>
                <span class="n">forward</span> <span class="o">=</span> <span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># z</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">forward</span><span class="p">)</span>  <span class="c1"># x</span>
                <span class="n">right</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>  <span class="c1"># y</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">right</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">forward</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

                <span class="c1"># Construct transformation matrix</span>
                <span class="n">T_W_C</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">transform_from</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                <span class="n">camera_poses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T_W_C</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">camera_poses</span>
<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h2 id="Camera-Intrinsic-and-Extrinsic-Estimation">
    Camera Intrinsic and Extrinsic Estimation
    <a class="anchor-link" href="#Camera-Intrinsic-and-Extrinsic-Estimation">
     ¶
    </a>
   </h2>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    To estimate both the camera intrinsics and extrinsics, we apply
    <strong>
     Zhang's method
    </strong>
    [
    <code>
     A flexible new technique for camera calibration
    </code>
    ], which involves the following steps:
   </p>
   <ol>
    <li>
     <strong>
      Estimating Homographies
     </strong>
     : We compute the transformation between the world and image planes for multiple camera views.
    </li>
    <li>
     <strong>
      Calibrating Camera Intrinsics
     </strong>
     : Using homographies, we solve for the camera intrinsic matrix $\mathbf{K}$.
    </li>
    <li>
     <strong>
      Estimating Camera Extrinsics
     </strong>
     : Given $\mathbf{K}$ and the homographies, we recover the camera pose for each view.
    </li>
   </ol>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Homography-Estimation">
    Homography Estimation
    <a class="anchor-link" href="#Homography-Estimation">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    A
    <strong>
     homography
    </strong>
    is a $3 \times 3$ matrix $\mathbf{H}$ that describes the transformation between two planes in projective space. In the context of camera calibration, it maps
    <strong>
     3D world points
    </strong>
    that lie on a known plane (e.g., the $Z = 0$ plane in our simulated problem) to their corresponding
    <strong>
     2D image points
    </strong>
    :
   </p>
   <p>
    $$
\tilde{\mathbf{p}}_I = \mathbf{H} \tilde{\mathbf{p}}_W
$$
   </p>
   <p>
    where:
   </p>
   <ul>
    <li>
     $\tilde{\mathbf{p}}_W = (x, y, 1)^\top$ is the homogeneous coordinate of a point in the world frame.
    </li>
    <li>
     $\tilde{\mathbf{p}}_I = (u, v, 1)^\top$ is the corresponding image point in homogeneous coordinates.
    </li>
    <li>
     $\mathbf{H}$ is the $3 \times 3$ homography matrix.
    </li>
   </ul>
   <p>
    Since all world points lie on the
    <strong>
     $Z=0$ plane
    </strong>
    , their 3D coordinates simplify to:
   </p>
   <p>
    $$
\mathbf{p}_W = (x, y, 0)^\top
$$
   </p>
   <p>
    The camera projection equation is given by:
   </p>
   <p>
    $$
\tilde{\mathbf{p}}_I = \mathbf{K} [\mathbf{R} \ | \ \mathbf{t}] \tilde{\mathbf{p}}_W
$$
   </p>
   <p>
    where:
   </p>
   <ul>
    <li>
     $\mathbf{K}$ is the
     <strong>
      intrinsic matrix
     </strong>
     , which defines how 3D points are projected onto the image plane.
    </li>
    <li>
     $[\mathbf{R} \ | \ \mathbf{t}]$ is the
     <strong>
      extrinsic transformation
     </strong>
     , with $\mathbf{R} \in SO(3)$ as the rotation matrix and $\mathbf{t} \in \mathbb{R}^3$ as the translation vector.
    </li>
    <li>
     Since world points are on the $Z=0$ plane, the third column of $\mathbf{R}$ is irrelevant in this mapping.
    </li>
   </ul>
   <p>
    Thus, we can rewrite the projection equation by extracting only the first two columns of $\mathbf{R}$:
   </p>
   <p>
    $$
\mathbf{H} = \mathbf{K} [\mathbf{r}_1 \quad \mathbf{r}_2 \quad \mathbf{t}]
$$
   </p>
   <p>
    where:
   </p>
   <ul>
    <li>
     $\mathbf{r}_1$ and $\mathbf{r}_2$ are the first two columns of the rotation matrix $\mathbf{R}$.
    </li>
    <li>
     $\mathbf{t}$ is the translation vector.
    </li>
    <li>
     The homography $\mathbf{H}$ encodes both the
     <strong>
      intrinsic
     </strong>
     ($\mathbf{K}$) and
     <strong>
      extrinsic
     </strong>
     ($\mathbf{R}, \mathbf{t}$) parameters of the camera.
    </li>
   </ul>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Normalization">
    Normalization
    <a class="anchor-link" href="#Normalization">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    To improve numerical stability, we normalize the points to be on unit circle before estimating the homography. This process ensures that the coordinate values are well-conditioned for numerical computations.
   </p>
   <p>
    Given a set of points $\mathbf{p}$, we compute a normalization transformation matrix $\mathbf{T}$:
   </p>
   <p>
    $$
\mathbf{T} =
\begin{bmatrix}
s &amp; 0 &amp; -s \bar{x} \\
0 &amp; s &amp; -s \bar{y} \\
0 &amp; 0 &amp; 1
\end{bmatrix}
$$
   </p>
   <p>
    Before estimating the homography, we apply this normalization process separately to the
    <strong>
     world points
    </strong>
    and
    <strong>
     image points
    </strong>
    , yielding two transformation matrices:
   </p>
   <p>
    The transformation matrix $\mathbf{T}_{\text{world}}$ normalizes the
    <strong>
     2D world points
    </strong>
    $(x, y)$:
   </p>
   <p>
    $$
\mathbf{T}_{\text{world}} =
\begin{bmatrix}
s_W &amp; 0 &amp; -s_W \bar{x}_W \\
0 &amp; s_W &amp; -s_W \bar{y}_W \\
0 &amp; 0 &amp; 1
\end{bmatrix}
$$
   </p>
   <p>
    Applying this transformation:
   </p>
   <p>
    $$
\tilde{\mathbf{p}}_W' = \mathbf{T}_{\text{world}} \tilde{\mathbf{p}}_W
$$
   </p>
   <p>
    Similarly, the transformation matrix $\mathbf{T}_{\text{pixel}}$ normalizes the
    <strong>
     2D image points
    </strong>
    $(u, v)$:
   </p>
   <p>
    $$
\mathbf{T}_{\text{pixel}} =
\begin{bmatrix}
s_I &amp; 0 &amp; -s_I \bar{u} \\
0 &amp; s_I &amp; -s_I \bar{v} \\
0 &amp; 0 &amp; 1
\end{bmatrix}
$$
   </p>
   <p>
    Applying this transformation:
   </p>
   <p>
    $$
\tilde{\mathbf{p}}_I' = \mathbf{T}_{\text{pixel}} \tilde{\mathbf{p}}_I
$$
   </p>
   <p>
    After applying these transformations, the normalized world points $\tilde{\mathbf{p}}_W'$ and image points $\tilde{\mathbf{p}}_I'$ are used to compute the homography $\mathbf{H}_{\text{norm}}$. The final homography is then
    <strong>
     denormalized
    </strong>
    :
   </p>
   <p>
    $$
\mathbf{H} = \mathbf{T}_{\text{pixel}}^{-1} \mathbf{H}_{\text{norm}} \mathbf{T}_{\text{world}}
$$
   </p>
   <p>
    This process ensures better numerical stability in solving for the homography using
    <strong>
     singular value decomposition (SVD)
    </strong>
    .
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [102]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Point Normalization</span>

<span class="k">def</span> <span class="nf">normalize_points</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Normalize points to have zero mean and unit variance."""</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">std_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_dev</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[[</span><span class="n">scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">scale</span> <span class="o">*</span> <span class="n">mean</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="o">-</span><span class="n">scale</span> <span class="o">*</span> <span class="n">mean</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="p">)</span>
    <span class="n">normalized_points</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">points</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))))[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">normalized_points</span><span class="p">,</span> <span class="n">T</span>
<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="DLT-for-homography-estimation">
    DLT for homography estimation
    <a class="anchor-link" href="#DLT-for-homography-estimation">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Using normalized world points $\mathbf{p}_W$ and image points $\mathbf{p}_I$, we construct a
    <strong>
     direct linear transformation (DLT)
    </strong>
    system.
   </p>
   <p>
    $$
\begin{bmatrix}
u \\
v \\
1
\end{bmatrix}
=
\begin{bmatrix}
h_{11} &amp; h_{12} &amp; h_{13} \\
h_{21} &amp; h_{22} &amp; h_{23} \\
h_{31} &amp; h_{32} &amp; h_{33}
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}
$$
   </p>
   <p>
    $$
u = \frac{h_{11} x + h_{12} y + h_{13}}{h_{31} x + h_{32} y + h_{33}}
$$
   </p>
   <p>
    $$
v = \frac{h_{21} x + h_{22} y + h_{23}}{h_{31} x + h_{32} y + h_{33}}
$$
   </p>
   <p>
    $$
h_{11} x + h_{12} y + h_{13} - u h_{31} x - u h_{32} y - u h_{33} = 0
$$
   </p>
   <p>
    $$
h_{21} x + h_{22} y + h_{23} - v h_{31} x - v h_{32} y - v h_{33} = 0
$$
   </p>
   <p>
    Each point correspondence $(x, y) \rightarrow (u, v)$ contributes two equations. To solve for all elements of $\mathbf{H}$, we stack these equations for multiple points into a
    <strong>
     linear system
    </strong>
    :
   </p>
   <p>
    $$
A \mathbf{h} = 0
$$
   </p>
   <p>
    where $\mathbf{h}$ is the 9-element vector.
   </p>
   <p>
    The
    <strong>
     system matrix
    </strong>
    $A$ for each point correspondence $(x, y) \rightarrow (u, v)$ is:
   </p>
   <p>
    $$
A =
\begin{bmatrix}
x &amp; y &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; -u x &amp; -u y &amp; -u \\
0 &amp; 0 &amp; 0 &amp; x &amp; y &amp; 1 &amp; -v x &amp; -v y &amp; -v
\end{bmatrix}
$$
   </p>
   <p>
    By stacking these equations for multiple points and solving the
    <strong>
     homogeneous linear system
    </strong>
    using
    <strong>
     singular value decomposition (SVD)
    </strong>
    , we obtain the best estimate for $\mathbf{H}$.
   </p>
   <p>
    Note: Since
    <code>
     H
    </code>
    has 8 DoF, at least 4 points are required to solve this equation, as each point provides 2 constraints. The points must not be collinear, as two points alone would determine the third, making the solution underdetermined.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [103]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Homography estimation</span>


<span class="k">def</span> <span class="nf">estimate_homography</span><span class="p">(</span><span class="n">world_points</span><span class="p">,</span> <span class="n">pixel_points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Estimate homography using normalized points."""</span>
    <span class="n">world_norm</span><span class="p">,</span> <span class="n">T_world</span> <span class="o">=</span> <span class="n">normalize_points</span><span class="p">(</span><span class="n">world_points</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">pixel_norm</span><span class="p">,</span> <span class="n">T_pixel</span> <span class="o">=</span> <span class="n">normalize_points</span><span class="p">(</span><span class="n">pixel_points</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">world_norm</span><span class="p">,</span> <span class="n">pixel_norm</span><span class="p">):</span>
        <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">u</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">u</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">u</span><span class="p">])</span>
        <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span><span class="p">])</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="c1"># Perform SVD and take the last row of V^T</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">H_norm</span> <span class="o">=</span> <span class="n">Vt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Denormalize the homography matrix</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">T_pixel</span><span class="p">)</span> <span class="o">@</span> <span class="n">H_norm</span> <span class="o">@</span> <span class="n">T_world</span>

    <span class="c1"># Normalize so that H[2,2] = 1</span>
    <span class="n">H</span> <span class="o">/=</span> <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span>

<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Camera-Intrinsic-Calibration">
    Camera Intrinsic Calibration
    <a class="anchor-link" href="#Camera-Intrinsic-Calibration">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Once multiple homographies $\mathbf{H}$ are computed, we estimate the camera intrinsic matrix $\mathbf{K}$.
   </p>
   <p>
    The homography relates to intrinsics and extrinsics:
   </p>
   <p>
    $$
\mathbf{H} = \mathbf{K} [ \mathbf{r}_1 \quad \mathbf{r}_2 \quad \mathbf{t} ]
$$
   </p>
   <p>
    where $\mathbf{r}_1, \mathbf{r}_2$ are the first two columns of the rotation matrix, and $\mathbf{t}$ is the translation vector.
   </p>
   <hr/>
   <p>
    <strong>
     - Constraint 1: Orthogonality of $\mathbf{r}_1$ and $\mathbf{r}_2$
    </strong>
    <br/>
    The rotation columns must be
    <strong>
     orthogonal
    </strong>
    , meaning:
   </p>
   <p>
    $$
\mathbf{r}_1^\top \mathbf{r}_2 = 0
$$
   </p>
   <p>
    Expanding in terms of $\mathbf{H}$:
   </p>
   <p>
    $$
(\mathbf{K}^{-1} \mathbf{h}_1)^\top (\mathbf{K}^{-1} \mathbf{h}_2) = 0
$$
   </p>
   <p>
    Rearranging:
   </p>
   <p>
    $$
\mathbf{h}_1^\top \mathbf{K}^{-\top} \mathbf{K}^{-1} \mathbf{h}_2 = 0
$$
   </p>
   <p>
    <strong>
     - Constraint 2: Equality of Norms of $\mathbf{r}_1$ and $\mathbf{r}_2$
    </strong>
    <br/>
    Since the columns of a rotation matrix have unit norms:
   </p>
   <p>
    $$
\mathbf{r}_1^\top \mathbf{r}_1 = \mathbf{r}_2^\top \mathbf{r}_2
$$
   </p>
   <p>
    Expanding in terms of $\mathbf{H}$:
   </p>
   <p>
    $$
\mathbf{h}_1^\top \mathbf{K}^{-\top} \mathbf{K}^{-1} \mathbf{h}_1 = \mathbf{h}_2^\top \mathbf{K}^{-\top} \mathbf{K}^{-1} \mathbf{h}_2
$$
   </p>
   <p>
    These two constraints hold for each homography and will allow us to estimate $\mathbf{K}$.
   </p>
   <hr/>
   <p>
    To simplify notation, we define:
   </p>
   <p>
    $$
\mathbf{B} = \mathbf{K}^{-\top} \mathbf{K}^{-1}
$$
   </p>
   <p>
    Since $\mathbf{B}$ is
    <strong>
     symmetric ($B = B^T$)
    </strong>
    , it has the form:
   </p>
   <p>
    $$
\mathbf{B} =
\begin{bmatrix}
B_{00} &amp; B_{01} &amp; B_{02} \\
B_{01} &amp; B_{11} &amp; B_{12} \\
B_{02} &amp; B_{12} &amp; B_{22}
\end{bmatrix}
$$
   </p>
   <p>
    Substituting $\mathbf{B}$ into our constraints:
   </p>
   <ol>
    <li>
     <p>
      <strong>
       Orthogonality Condition:
      </strong>
     </p>
     <p>
      $$
\mathbf{h}_1^\top \mathbf{B} \mathbf{h}_2 = 0
$$
     </p>
    </li>
    <li>
     <p>
      <strong>
       Equality of Norms Condition:
      </strong>
     </p>
     <p>
      $$
\mathbf{h}_1^\top \mathbf{B} \mathbf{h}_1 = \mathbf{h}_2^\top \mathbf{B} \mathbf{h}_2
$$
     </p>
    </li>
   </ol>
   <p>
    These provide two
    <strong>
     linear equations
    </strong>
    for each homography $\mathbf{H}$.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Let the vector $\mathbf{b}$ represents the
    <strong>
     six unknown elements
    </strong>
    of the intrinsic constraint matrix $\mathbf{B}$:
   </p>
   <p>
    $$
\mathbf{b} =
\begin{bmatrix}
B_{00} \\ B_{01} \\ B_{11} \\ B_{02} \\ B_{12} \\ B_{22}
\end{bmatrix}
$$
   </p>
   <p>
    The term ( v_{12} ) is derived from the
    <strong>
     orthogonality constraint
    </strong>
    of the rotation columns:
   </p>
   <p>
    $$
\mathbf{h}_1^\top \mathbf{B} \mathbf{h}_2 = 0
$$
   </p>
   <p>
    Expanding this gives the constraint vector:
   </p>
   <p>
    $$
v_{12} =
\begin{bmatrix}
h_{11} h_{12} \\
h_{11} h_{22} + h_{21} h_{12} \\
h_{21} h_{22} \\
h_{11} h_{32} + h_{31} h_{12} \\
h_{21} h_{32} + h_{31} h_{22} \\
h_{31} h_{32}
\end{bmatrix}
$$
   </p>
   <p>
    which contributes one
    <strong>
     row
    </strong>
    in the constraint matrix $V$ as $v_{12}^T b = 0$.
   </p>
   <p>
    The terms ( v_{11} ) and ( v_{22} ) are derived from the
    <strong>
     equal norm constraint
    </strong>
    :
   </p>
   <p>
    $$
\mathbf{h}_1^\top \mathbf{B} \mathbf{h}_1 = \mathbf{h}_2^\top \mathbf{B} \mathbf{h}_2
$$
   </p>
   <p>
    Expanding these gives:
   </p>
   <p>
    $$
v_{11} =
\begin{bmatrix}
h_{11}^2 \\
2 h_{11} h_{21} \\
h_{21}^2 \\
2 h_{11} h_{31} \\
2 h_{21} h_{31} \\
h_{31}^2
\end{bmatrix}
v_{22} =
\begin{bmatrix}
h_{12}^2 \\
2 h_{12} h_{22} \\
h_{22}^2 \\
2 h_{12} h_{32} \\
2 h_{22} h_{32} \\
h_{32}^2
\end{bmatrix}
$$
   </p>
   <p>
    which provides another
    <strong>
     row
    </strong>
    in the constraint matrix $V$ as $(v_{11} - v_{22})^\top \mathbf{b} = 0$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    We solve for $V \mathbf{b} = 0$ using
    <strong>
     SVD
    </strong>
    . The solution is obtained as the
    <strong>
     singular vector corresponding to the smallest singular value
    </strong>
    .
   </p>
   <p>
    Finally we e extract the intrinsic parameters:
   </p>
   <ul>
    <li>
     $v_0 = \frac{B_{01} B_{02} - B_{00} B_{12}}{B_{00} B_{11} - B_{01}^2}$
    </li>
    <li>
     $\lambda = B_{22} - \frac{B_{02}^2 + v_0 (B_{01} B_{02} - B_{00} B_{12})}{B_{00}}$
    </li>
    <li>
     $\alpha = \sqrt{\lambda / B_{00}}$ (focal length in $x$)
    </li>
    <li>
     $\beta = \sqrt{\lambda B_{00} / (B_{00} B_{11} - B_{01}^2)}$ (focal length in $y$)
    </li>
    <li>
     $\gamma = -B_{01} \alpha^2 \beta / \lambda$ (skew factor)
    </li>
    <li>
     $u_0 = \gamma v_0 / \beta - B_{02} \alpha^2 / \lambda$ (principal point)
    </li>
   </ul>
   <p>
    The intrinsic matrix is then:
   </p>
   <p>
    $$
\mathbf{K} =
\begin{bmatrix}
\alpha &amp; \gamma &amp; u_0 \\
0 &amp; \beta &amp; v_0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
$$
   </p>
   <p>
    Note: There may be degenerate cases, which is why we check the condition number when solving
    <code>
     B
    </code>
    .
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [104]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Calibrate intrinsics</span>


<span class="k">def</span> <span class="nf">calibrate_intrinsics</span><span class="p">(</span><span class="n">homographies</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># Number of homographies</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">homographies</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">"At least two homographies are required for calibration"</span>

    <span class="c1"># Construct the constraint matrix V</span>
    <span class="n">V</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">H</span> <span class="ow">in</span> <span class="n">homographies</span><span class="p">:</span>
        <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span> <span class="o">=</span> <span class="n">H</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">H</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Compute the constraint vectors</span>
        <span class="n">v_12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">h1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">h1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">h1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">h1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">h1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">h1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">h1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">v_11</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">h1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="n">h1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">h1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="n">h1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="n">h1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">h1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">h1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">v_22</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">h2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">h2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">h2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">V</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_12</span><span class="p">)</span>
        <span class="n">V</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_11</span> <span class="o">-</span> <span class="n">v_22</span><span class="p">)</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="c1"># Solve for the null space of V to get b (which defines B)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">rank_V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Rank of V: </span><span class="si">{</span><span class="n">rank_V</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Singular values of V:"</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Condition number of V:"</span><span class="p">,</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">Vt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Construct the B matrix</span>
    <span class="n">B00</span><span class="p">,</span> <span class="n">B01</span><span class="p">,</span> <span class="n">B11</span><span class="p">,</span> <span class="n">B02</span><span class="p">,</span> <span class="n">B12</span><span class="p">,</span> <span class="n">B22</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">B00</span><span class="p">,</span> <span class="n">B01</span><span class="p">,</span> <span class="n">B02</span><span class="p">],</span> <span class="p">[</span><span class="n">B01</span><span class="p">,</span> <span class="n">B11</span><span class="p">,</span> <span class="n">B12</span><span class="p">],</span> <span class="p">[</span><span class="n">B02</span><span class="p">,</span> <span class="n">B12</span><span class="p">,</span> <span class="n">B22</span><span class="p">]])</span>

    <span class="c1"># Compute intrinsic parameters</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="p">(</span><span class="n">B01</span> <span class="o">*</span> <span class="n">B02</span> <span class="o">-</span> <span class="n">B00</span> <span class="o">*</span> <span class="n">B12</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">B00</span> <span class="o">*</span> <span class="n">B11</span> <span class="o">-</span> <span class="n">B01</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">lambda_</span> <span class="o">=</span> <span class="n">B22</span> <span class="o">-</span> <span class="p">(</span><span class="n">B02</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">v0</span> <span class="o">*</span> <span class="p">(</span><span class="n">B01</span> <span class="o">*</span> <span class="n">B02</span> <span class="o">-</span> <span class="n">B00</span> <span class="o">*</span> <span class="n">B12</span><span class="p">))</span> <span class="o">/</span> <span class="n">B00</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_</span> <span class="o">/</span> <span class="n">B00</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_</span> <span class="o">*</span> <span class="n">B00</span> <span class="o">/</span> <span class="p">(</span><span class="n">B00</span> <span class="o">*</span> <span class="n">B11</span> <span class="o">-</span> <span class="n">B01</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="o">-</span><span class="n">B01</span> <span class="o">*</span> <span class="n">alpha</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">beta</span> <span class="o">/</span> <span class="n">lambda_</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">v0</span> <span class="o">/</span> <span class="n">beta</span> <span class="o">-</span> <span class="n">B02</span> <span class="o">*</span> <span class="n">alpha</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">lambda_</span>

    <span class="c1"># Intrinsic matrix K</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">alpha</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">u0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">v0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="c1"># Intrinsic matrix K</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">alpha</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">u0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">v0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

    <span class="k">return</span> <span class="n">K</span>


<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Camera-Extrinsic-Estimation">
    Camera Extrinsic Estimation
    <a class="anchor-link" href="#Camera-Extrinsic-Estimation">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Given $\mathbf{K}$ and a homography $\mathbf{H}$, the extrinsic parameters (rotation $\mathbf{R}$ and translation $\mathbf{t}$) are computed as:
   </p>
   <p>
    $$
\mathbf{M} = \mathbf{K}^{-1} \mathbf{H}
$$
   </p>
   <p>
    where:
   </p>
   <ul>
    <li>
     $\mathbf{r}_1 = \frac{\mathbf{M}_{:,1}}{\lambda}$
    </li>
    <li>
     $\mathbf{r}_2 = \frac{\mathbf{M}_{:,2}}{\lambda}$
    </li>
    <li>
     $\mathbf{r}_3 = \mathbf{r}_1 \times \mathbf{r}_2$ (ensuring orthogonality)
    </li>
    <li>
     $\mathbf{t} = \frac{\mathbf{M}_{:,3}}{\lambda}$
    </li>
   </ul>
   <p>
    The
    <strong>
     orthonormalization
    </strong>
    step ensures $\mathbf{R}$ is a valid rotation matrix.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [105]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Compute extrinsic parameters</span>


<span class="k">def</span> <span class="nf">compute_extrinsics</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
    <span class="n">K_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">K_inv</span> <span class="o">@</span> <span class="n">H</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="c1"># r1 and r2 should be unit vectors</span>
    <span class="n">lambda_</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">/</span> <span class="n">lambda_</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">r2</span> <span class="o">/</span> <span class="n">lambda_</span>
    <span class="n">r3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">))</span>
    <span class="n">U</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="n">R_ortho</span> <span class="o">=</span> <span class="n">U</span> <span class="o">@</span> <span class="n">Vt</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">R_ortho</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">Vt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Flip the last row of Vt</span>
        <span class="n">R_ortho</span> <span class="o">=</span> <span class="n">U</span> <span class="o">@</span> <span class="n">Vt</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">/</span> <span class="n">lambda_</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">transform_from</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>


<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Running-the-Camera-Calibration-Simulation">
    Running the Camera Calibration Simulation
    <a class="anchor-link" href="#Running-the-Camera-Calibration-Simulation">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Using the simulated world points and camera poses, we generate image observations:
   </p>
   <ol>
    <li>
     <strong>
      Project world points into the image plane
     </strong>
     using $\mathbf{K}$ and camera poses $\mathbf{T}_{WC}$.
    </li>
    <li>
     <strong>
      Compute homographies
     </strong>
     from world-image correspondences.
    </li>
    <li>
     <strong>
      Estimate camera intrinsics
     </strong>
     using multiple homographies.
    </li>
    <li>
     <strong>
      Recover camera extrinsics
     </strong>
     for each view.
    </li>
   </ol>
   <p>
    To validate the calibration:
   </p>
   <ul>
    <li>
     <strong>
      Intrinsic matrix
     </strong>
     $\mathbf{K}_{\text{tested}}$ should match the ground truth $\mathbf{K}$.
    </li>
    <li>
     <strong>
      Estimated camera poses
     </strong>
     $\mathbf{T}_{WC}^{\text{tested}}$ should align with the expected ones.
    </li>
   </ul>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [106]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Camera CalibrationSimulation</span>

<span class="n">camera_poses_expected</span> <span class="o">=</span> <span class="n">generate_camera_poses</span><span class="p">()</span>

<span class="n">pixel_obs_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">T_W_C</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">camera_poses_expected</span><span class="p">):</span>
    <span class="c1"># Each column is a point</span>
    <span class="n">points_in_C</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">T_W_C</span><span class="p">)</span> <span class="o">@</span> <span class="n">homogeneous_world_points</span><span class="p">)[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">uv</span> <span class="o">=</span> <span class="n">K</span> <span class="o">@</span> <span class="n">points_in_C</span>
    <span class="n">uv_normalized</span> <span class="o">=</span> <span class="n">uv</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">uv</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">pixel_obs_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uv_normalized</span><span class="p">)</span>

<span class="c1"># Compute homographies with normalization</span>
<span class="n">homographies</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">T_W_C</span><span class="p">,</span> <span class="n">pixel_obs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">camera_poses_expected</span><span class="p">,</span> <span class="n">pixel_obs_list</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">estimate_homography</span><span class="p">(</span><span class="n">world_points</span><span class="p">,</span> <span class="n">pixel_points</span><span class="o">=</span><span class="n">pixel_obs</span><span class="p">)</span>

    <span class="c1"># Expected homography from intrinsic &amp; extrinsic parameters</span>
    <span class="n">T_C_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">T_W_C</span><span class="p">)</span>
    <span class="n">h_expected</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T_C_W</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
    <span class="n">h_expected</span> <span class="o">/=</span> <span class="n">h_expected</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Check if estimated homography is close to expected</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">h_expected</span><span class="p">),</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">h</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">h_expected</span><span class="si">=}</span><span class="s2">"</span>

    <span class="n">homographies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

<span class="c1"># Compute intrinsic parameters</span>
<span class="n">K_tested</span> <span class="o">=</span> <span class="n">calibrate_intrinsics</span><span class="p">(</span><span class="n">homographies</span><span class="o">=</span><span class="n">homographies</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">K_tested</span><span class="p">),</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">K</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">K_tested</span><span class="si">=}</span><span class="s2">"</span>


<span class="c1"># Camera poses are expressed in world frame.</span>
<span class="n">camera_poses_tested</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">T_W_C_expected</span><span class="p">,</span> <span class="n">H</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">camera_poses_expected</span><span class="p">,</span> <span class="n">homographies</span><span class="p">):</span>
    <span class="n">T_W_C_tested</span> <span class="o">=</span> <span class="n">compute_extrinsics</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="n">K_tested</span><span class="p">)</span>
    <span class="n">camera_poses_tested</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T_W_C_tested</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">T_W_C_expected</span><span class="p">,</span> <span class="n">T_W_C_tested</span><span class="p">)</span>

<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
 <div class="output_wrapper">
  <div class="output">
   <div class="output_area">
    <div class="prompt">
    </div>
    <div class="output_subarea output_stream output_stdout output_text">
     <pre>Rank of V: 5
Singular values of V: [3.7186e+04 2.8990e+04 3.3617e+03 1.1681e+01 1.6096e+00 1.4826e-16]
Condition number of V: 2.508181506987467e+20
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h2 id="Hand-Eye-Calibration">
    Hand-Eye Calibration
    <a class="anchor-link" href="#Hand-Eye-Calibration">
     ¶
    </a>
   </h2>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Hand-Eye-Calibration-using-(-AX-=-XB-)">
    Hand-Eye Calibration using ( AX = XB )
    <a class="anchor-link" href="#Hand-Eye-Calibration-using-(-AX-=-XB-)">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    I primarily follow
    <code>
     Robot Sensor Calibration: Solving AX = XB on the Euclidean Group
    </code>
    , except that I use SVD to solve for rotation, similar to the approach in point cloud alignment.
   </p>
   <p>
    Hand-eye calibration is the process of estimating the transformation between a
    <strong>
     camera
    </strong>
    and a
    <strong>
     robot end-effector
    </strong>
    when the camera is rigidly mounted on the robot. This calibration helps in accurately relating observations from the camera to the robot's movement.
   </p>
   <p>
    In this section, we implement the
    <strong>
     Park &amp; Martin method
    </strong>
    to solve the classic
    <strong>
     hand-eye calibration equation
    </strong>
    :
   </p>
   <p>
    $$
AX = XB
$$
   </p>
   <p>
    where:
   </p>
   <ul>
    <li>
     $A_i$ represents the relative transformation between two
     <strong>
      camera
     </strong>
     poses $T_{C_iC_j}$
    </li>
    <li>
     $B_i$ represents the relative transformation between two
     <strong>
      end-effector
     </strong>
     poses $T_{E_iE_j}$.
    </li>
    <li>
     $X$ is the unknown transformation from the
     <strong>
      camera frame
     </strong>
     to the
     <strong>
      end-effector frame
     </strong>
     $T_{CE}$.
    </li>
   </ul>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Estimating-Rotation-$%5Cmathbf%7BR_%7BCE%7D%7D$-and-$%5Cmathbf%7Bt_%7BCE%7D%7D$">
    Estimating Rotation $\mathbf{R_{CE}}$ and $\mathbf{t_{CE}}$
    <a class="anchor-link" href="#Estimating-Rotation-$%5Cmathbf%7BR_%7BCE%7D%7D$-and-$%5Cmathbf%7Bt_%7BCE%7D%7D$">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Extracting the rotation component from $T_{C_i C_j} X = X T_{E_i E_j}$,we obtain:
$$
R_{C_i C_j} R_{CE} = R_{CE} R_{E_i E_j}
$$
   </p>
   <p>
    Taking the
    <strong>
     logarithm map
    </strong>
    of the rotation part:
   </p>
   <p>
    $$
\log( R_{C_i C_j} ) = R \log( R_{E_i E_j} ) R^{-1}
$$
   </p>
   <p>
    Since the
    <strong>
     Lie algebra
    </strong>
    of rotations follows:
   </p>
   <p>
    $$
\log( R_{C_i C_j} ) = [\alpha]
$$
   </p>
   <p>
    $$
\log( R_{E_i E_j} ) = [\beta]
$$
   </p>
   <p>
    We obtain the relationship:
   </p>
   <p>
    $$
[\alpha] = R [\beta] R^{-1}
$$
   </p>
   <p>
    Using vector form:
   </p>
   <p>
    $$
\alpha = R \beta
$$
   </p>
   <p>
    Given multiple transformation pairs $\alpha_i, \beta_i$, we solve for $R$ by minimizing:
   </p>
   <p>
    $$
\sum \| \alpha_i - R \beta_i \|^2
$$
   </p>
   <p>
    which is solved using
    <strong>
     SVD decomposition
    </strong>
    .
   </p>
   <hr/>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Once $R_{CE}$ is known, the equation for translation becomes:
   </p>
   <p>
    $$
t_{C_i C_j} = R t_{E_i E_j} + t
$$
   </p>
   <p>
    Rearranging:
   </p>
   <p>
    $$
(I - R) t_{E_i E_j} = t_{C_i C_j} - t
$$
   </p>
   <p>
    This forms an
    <strong>
     overdetermined linear system
    </strong>
    , which is solved using
    <strong>
     least squares regression
    </strong>
    .
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [107]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># calibrate hand eye</span>

<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">logm</span>


<span class="k">def</span> <span class="nf">logm_vector</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">T</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">log_R</span> <span class="o">=</span> <span class="n">logm</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">log_R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">log_R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">log_R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>


<span class="k">def</span> <span class="nf">calibrate_hand_eye</span><span class="p">(</span><span class="n">T_Ci_Cj_list</span><span class="p">,</span> <span class="n">T_Ei_Ej_list</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">T_Ci_Cj_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
    <span class="n">n_data</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">T_Ci_Cj_list</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span> <span class="o">*</span> <span class="n">n_data</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span> <span class="o">*</span> <span class="n">n_data</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># This is from the example in the paper</span>
    <span class="k">if</span> <span class="n">n_data</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">logm_vector</span><span class="p">(</span><span class="n">T_Ci_Cj_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">logm_vector</span><span class="p">(</span><span class="n">T_Ei_Ej_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">alpha2</span> <span class="o">=</span> <span class="n">logm_vector</span><span class="p">(</span><span class="n">T_Ci_Cj_list</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">beta2</span> <span class="o">=</span> <span class="n">logm_vector</span><span class="p">(</span><span class="n">T_Ei_Ej_list</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">alpha3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">alpha2</span><span class="p">)</span>
        <span class="n">beta3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">beta2</span><span class="p">)</span>
        <span class="n">A_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">alpha2</span><span class="p">,</span> <span class="n">alpha3</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">B_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">beta</span><span class="p">,</span> <span class="n">beta2</span><span class="p">,</span> <span class="n">beta3</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">A_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">B_</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">T_Ci_Cj_list</span><span class="p">,</span> <span class="n">T_Ei_Ej_list</span><span class="p">):</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">logm_vector</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">logm_vector</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">+=</span> <span class="n">beta</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">alpha</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># I am ssing SVD instead of the way described in the paper.</span>
        <span class="c1"># R = scipy.linalg.sqrtm(np.linalg.inv(M.T @ M)) @ M.T</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">Vt</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_data</span><span class="p">):</span>
        <span class="n">Ra</span> <span class="o">=</span> <span class="n">T_Ci_Cj_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">ta</span> <span class="o">=</span> <span class="n">T_Ci_Cj_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">tb</span> <span class="o">=</span> <span class="n">T_Ei_Ej_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

        <span class="n">C</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">i</span> <span class="p">:</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">Ra</span>
        <span class="n">d</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">i</span> <span class="p">:</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span> <span class="o">-</span> <span class="n">R</span> <span class="o">@</span> <span class="n">tb</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">C</span><span class="p">)</span> <span class="o">@</span> <span class="n">C</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">d</span>
    <span class="k">return</span> <span class="n">pt</span><span class="o">.</span><span class="n">transform_from</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>


<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Run-Hand-Eye-Calibration-Simulation">
    Run Hand-Eye Calibration Simulation
    <a class="anchor-link" href="#Run-Hand-Eye-Calibration-Simulation">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    To validate the
    <strong>
     hand-eye calibration
    </strong>
    method, we generate a simulation where a
    <strong>
     camera
    </strong>
    is rigidly attached to a
    <strong>
     robot end-effector
    </strong>
    . The simulation involves:
   </p>
   <ol>
    <li>
     <strong>
      Generating ground-truth transformations
     </strong>
     for both the camera and end-effector.
    </li>
    <li>
     <strong>
      Computing end-effector poses
     </strong>
     based on the expected transformations.
    </li>
    <li>
     <strong>
      Introducing noise
     </strong>
     to simulate real-world conditions.
    </li>
    <li>
     <strong>
      Extracting transformation pairs
     </strong>
     to solve for hand-eye calibration.
    </li>
    <li>
     <strong>
      Testing the estimated transformation
     </strong>
     against the ground truth.
    </li>
   </ol>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [108]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Run Hand-eye calibration Simulation</span>

<span class="n">T_E_C_expected</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">transform_from</span><span class="p">(</span>
    <span class="n">R</span><span class="o">=</span><span class="n">pr</span><span class="o">.</span><span class="n">matrix_from_axis_angle</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">88</span><span class="p">)]),</span>
    <span class="n">p</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">]),</span>
<span class="p">)</span>
<span class="n">T_C_E_expected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">T_E_C_expected</span><span class="p">)</span>
<span class="n">T_W_B_expected</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">transform_from</span><span class="p">(</span>
    <span class="n">R</span><span class="o">=</span><span class="n">pr</span><span class="o">.</span><span class="n">matrix_from_axis_angle</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">90</span><span class="p">)]),</span> <span class="n">p</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">])</span>
<span class="p">)</span>
<span class="n">T_B_W_expected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">T_W_B_expected</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">generate_end_effector_poses</span><span class="p">(</span>
    <span class="n">camera_poses_expected</span><span class="p">,</span> <span class="n">noise_factor</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">error_low_bound_m</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">error_high_bound_m</span><span class="o">=</span><span class="mi">7</span>
<span class="p">):</span>
    <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="n">errors_expected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
        <span class="n">error_low_bound_m</span> <span class="o">*</span> <span class="n">noise_factor</span><span class="p">,</span>
        <span class="n">error_high_bound_m</span> <span class="o">*</span> <span class="n">noise_factor</span><span class="p">,</span>
        <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">camera_poses_expected</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="c1"># These are in Base frame</span>
    <span class="n">end_effector_poses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">end_effector_poses_noisy</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">T_W_C</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">camera_poses_expected</span><span class="p">):</span>
        <span class="n">T_B_E</span> <span class="o">=</span> <span class="n">T_B_W_expected</span> <span class="o">@</span> <span class="n">T_W_C</span> <span class="o">@</span> <span class="n">T_C_E_expected</span>
        <span class="n">T_B_E_noisy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">T_B_E</span><span class="p">)</span>
        <span class="n">T_B_E_noisy</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">errors_expected</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">end_effector_poses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T_B_E</span><span class="p">)</span>
        <span class="n">end_effector_poses_noisy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T_B_E_noisy</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">end_effector_poses</span><span class="p">,</span>
        <span class="n">end_effector_poses_noisy</span><span class="p">,</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">errors_expected</span><span class="p">],</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">generate_AB_pairs</span><span class="p">(</span><span class="n">camera_poses</span><span class="p">,</span> <span class="n">end_effector_poses</span><span class="p">,</span> <span class="n">n_pairs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">T_C_E_expected</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="c1"># pick n random pairs</span>
    <span class="n">T_Ci_Cj_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">T_Ei_Ej_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">indics</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">end_effector_poses</span><span class="p">))</span>
    <span class="n">selected_pairs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_pairs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_pairs</span><span class="p">:</span>
        <span class="n">pair</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">indics</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">sorted_pair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">pair</span><span class="p">))</span>  <span class="c1"># Ensure pairs are ordered</span>
        <span class="k">if</span> <span class="n">sorted_pair</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">selected_pairs</span><span class="p">:</span>
            <span class="n">selected_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sorted_pair</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">selected_pairs</span><span class="p">:</span>
        <span class="n">T_W_Ci</span> <span class="o">=</span> <span class="n">camera_poses</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">T_W_Cj</span> <span class="o">=</span> <span class="n">camera_poses</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">T_Ci_Cj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">T_W_Ci</span><span class="p">)</span> <span class="o">@</span> <span class="n">T_W_Cj</span>
        <span class="n">T_B_Ei</span> <span class="o">=</span> <span class="n">end_effector_poses</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">T_B_Ej</span> <span class="o">=</span> <span class="n">end_effector_poses</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">T_Ei_Ej</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">T_B_Ei</span><span class="p">)</span> <span class="o">@</span> <span class="n">T_B_Ej</span>
        <span class="n">T_Ci_Cj_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T_Ci_Cj</span><span class="p">)</span>
        <span class="n">T_Ei_Ej_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T_Ei_Ej</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">T_C_E_expected</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Whe we have perfect inputs, we can check AX = XB</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">T_Ci_Cj</span> <span class="o">@</span> <span class="n">T_C_E_expected</span><span class="p">,</span> <span class="n">T_C_E_expected</span> <span class="o">@</span> <span class="n">T_Ei_Ej</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">T_Ci_Cj_list</span><span class="p">,</span> <span class="n">T_Ei_Ej_list</span>


<span class="n">noise_factor</span> <span class="o">=</span> <span class="mf">1e-3</span>
<span class="n">n_pairs</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">end_effector_poses</span><span class="p">,</span> <span class="n">end_effector_poses_noisy</span><span class="p">,</span> <span class="n">errors_expected</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">generate_end_effector_poses</span><span class="p">(</span><span class="n">camera_poses_expected</span><span class="p">,</span> <span class="n">noise_factor</span><span class="o">=</span><span class="n">noise_factor</span><span class="p">)</span>
<span class="p">)</span>

<span class="n">T_Ci_Cj_list</span><span class="p">,</span> <span class="n">T_Ei_Ej_list</span> <span class="o">=</span> <span class="n">generate_AB_pairs</span><span class="p">(</span>
    <span class="n">camera_poses_expected</span><span class="p">,</span>
    <span class="n">end_effector_poses</span><span class="p">,</span>
    <span class="n">n_pairs</span><span class="o">=</span><span class="n">n_pairs</span><span class="p">,</span>
    <span class="n">T_C_E_expected</span><span class="o">=</span><span class="n">T_C_E_expected</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">T_C_E_tested</span> <span class="o">=</span> <span class="n">calibrate_hand_eye</span><span class="p">(</span><span class="n">T_Ci_Cj_list</span><span class="p">,</span> <span class="n">T_Ei_Ej_list</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">T_C_E_tested</span><span class="p">,</span> <span class="n">T_C_E_expected</span><span class="p">)</span>
<span class="c1"># AX = XB -&gt; T_Ci_Cj @ T_C_E_expected = T_C_E_expected @ T_Ei_Ej</span>
<span class="c1"># We can also have T_Wi_Wj @ T_W_B_expected = T_W_B_expected @ T_Bi_Bj</span>
<span class="n">T_Wi_Wj_list</span><span class="p">,</span> <span class="n">T_Bi_Bj_list</span> <span class="o">=</span> <span class="n">generate_AB_pairs</span><span class="p">(</span>
    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">T_W_C</span><span class="p">)</span> <span class="k">for</span> <span class="n">T_W_C</span> <span class="ow">in</span> <span class="n">camera_poses_expected</span><span class="p">],</span>
    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">T_B_E</span><span class="p">)</span> <span class="k">for</span> <span class="n">T_B_E</span> <span class="ow">in</span> <span class="n">end_effector_poses</span><span class="p">],</span>
    <span class="n">n_pairs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">T_C_E_expected</span><span class="o">=</span><span class="n">T_W_B_expected</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">T_W_B_tested</span> <span class="o">=</span> <span class="n">calibrate_hand_eye</span><span class="p">(</span><span class="n">T_Wi_Wj_list</span><span class="p">,</span> <span class="n">T_Bi_Bj_list</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">T_W_B_tested</span><span class="p">,</span> <span class="n">T_W_B_expected</span><span class="p">)</span>


<span class="n">T_Ci_Cj_list</span><span class="p">,</span> <span class="n">T_Ei_Ej_list</span> <span class="o">=</span> <span class="n">generate_AB_pairs</span><span class="p">(</span>
    <span class="n">camera_poses_tested</span><span class="p">,</span> <span class="n">end_effector_poses</span><span class="p">,</span> <span class="n">n_pairs</span><span class="o">=</span><span class="n">n_pairs</span>
<span class="p">)</span>
<span class="n">T_C_E_tested</span> <span class="o">=</span> <span class="n">calibrate_hand_eye</span><span class="p">(</span><span class="n">T_Ci_Cj_list</span><span class="p">,</span> <span class="n">T_Ei_Ej_list</span><span class="p">)</span>
<span class="c1"># This seems that our camera_poses_tested is quite good...</span>
<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">T_C_E_tested</span><span class="p">,</span> <span class="n">T_C_E_expected</span><span class="p">)</span>

<span class="c1"># Finally, try use noisy estimation</span>
<span class="n">T_Ci_Cj_list</span><span class="p">,</span> <span class="n">T_Ei_Ej_list</span> <span class="o">=</span> <span class="n">generate_AB_pairs</span><span class="p">(</span>
    <span class="n">camera_poses_tested</span><span class="p">,</span> <span class="n">end_effector_poses_noisy</span><span class="p">,</span> <span class="n">n_pairs</span><span class="o">=</span><span class="n">n_pairs</span>
<span class="p">)</span>
<span class="n">T_C_E_tested</span> <span class="o">=</span> <span class="n">calibrate_hand_eye</span><span class="p">(</span><span class="n">T_Ci_Cj_list</span><span class="p">,</span> <span class="n">T_Ei_Ej_list</span><span class="p">)</span>

<span class="n">T_Wi_Wj_list</span><span class="p">,</span> <span class="n">T_Bi_Bj_list</span> <span class="o">=</span> <span class="n">generate_AB_pairs</span><span class="p">(</span>
    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">T_W_C</span><span class="p">)</span> <span class="k">for</span> <span class="n">T_W_C</span> <span class="ow">in</span> <span class="n">camera_poses_tested</span><span class="p">],</span>
    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">T_B_E</span><span class="p">)</span> <span class="k">for</span> <span class="n">T_B_E</span> <span class="ow">in</span> <span class="n">end_effector_poses</span><span class="p">],</span>
    <span class="n">n_pairs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">T_C_E_expected</span><span class="o">=</span><span class="n">T_W_B_expected</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># or T_W_B_tested = camera_poses_tested[0] @ T_C_E_tested @ np.linalg.inv(end_effector_poses_noisy[0])</span>
<span class="n">T_W_B_tested</span> <span class="o">=</span> <span class="n">calibrate_hand_eye</span><span class="p">(</span><span class="n">T_Wi_Wj_list</span><span class="p">,</span> <span class="n">T_Bi_Bj_list</span><span class="p">)</span>
<span class="n">T_B_W_tested</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">T_W_B_tested</span><span class="p">)</span>

<span class="c1"># assert np.allclose(T_C_E_tested, T_C_E_expected)</span>
<span class="c1"># assert np.allclose(T_W_B_tested, T_W_B_expected)</span>

<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h2 id="Factor-Graph-based-Hand-Eye-Calibration-Optimization">
    Factor Graph based Hand-Eye Calibration Optimization
    <a class="anchor-link" href="#Factor-Graph-based-Hand-Eye-Calibration-Optimization">
     ¶
    </a>
   </h2>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Several degenerate cases can arise in the previous processes, such as insufficient views to estimate $H$ or $K$ and inadequate movement to determine $T_{CE}$. Additionally, real-world measurements are imperfect, with errors in pixel observations, robot arm end-effector poses, and other factors.
   </p>
   <p>
    When performing hand-eye calibration, it is ideal to capture a diverse range of calibration board views and execute various robot arm movements. Given the limited field of view of a single camera with a single calibration board, using multiple boards placed throughout the room can improve accuracy.
   </p>
   <p>
    To address these issues after we have enought data, we formulate the problem as an optimization task to estimate the variables of interest.
   </p>
   <p>
    Note: In this tutorial, we will not simulate the optimization of camera intrinsics.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Import-Libraries">
    Import Libraries
    <a class="anchor-link" href="#Import-Libraries">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [109]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Import symforce</span>

<span class="kn">import</span> <span class="nn">symforce</span>

<span class="n">symforce</span><span class="o">.</span><span class="n">set_epsilon_to_symbol</span><span class="p">()</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">symforce.values</span> <span class="kn">import</span> <span class="n">Values</span>
<span class="kn">import</span> <span class="nn">symforce.symbolic</span> <span class="k">as</span> <span class="nn">sf</span>

<span class="kn">from</span> <span class="nn">symforce.opt.factor</span> <span class="kn">import</span> <span class="n">Factor</span>
<span class="kn">from</span> <span class="nn">symforce.opt.optimizer</span> <span class="kn">import</span> <span class="n">Optimizer</span>

<span class="kn">import</span> <span class="nn">sym</span>


<span class="k">def</span> <span class="nf">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">Pose3</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="n">sym</span><span class="o">.</span><span class="n">Rot3</span><span class="o">.</span><span class="n">from_rotation_matrix</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]),</span> <span class="n">t</span><span class="o">=</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>


<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Define-Residual-Functions">
    Define Residual Functions
    <a class="anchor-link" href="#Define-Residual-Functions">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    The function
    <code>
     reprojection_residual_from_camera
    </code>
    computes the reprojection error of a landmark observed by a camera. It assumes that the camera pose is being optimized in the world frame.
   </p>
   <ul>
    <li>
     $T_{W_C}^{-1} \cdot W_t^{landmark}$ transforms the landmark position into the camera frame.
    </li>
    <li>
     $K \cdot (...)$ projects the transformed point into image coordinates.
    </li>
    <li>
     The residual is computed as the difference between the observed pixel location
    </li>
    <li>
     $uv_{obs}$ and the projected landmark position.
    </li>
   </ul>
   <p>
    To enforce consistency in transformations, the function
    <code>
     pose_loop_residual
    </code>
    ensures that the transformation chain forms a valid loop $T_{BB} = T_{BW} \cdot T_{WC} \cdot T_{CE} \cdot (T_{BE_n} \cdot T_{E_nE})^{-1}$.
   </p>
   <p>
    NOTE: We might also want to have a prior constraint on error correction term $T_{E_nE}$.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [110]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Residual functions</span>


<span class="c1"># This is purely optimizing camera poses in world frame</span>
<span class="k">def</span> <span class="nf">reprojection_residual_from_camera</span><span class="p">(</span>
    <span class="n">T_W_C</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">Pose3</span><span class="p">,</span>
    <span class="n">W_t_landmark</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">,</span>
    <span class="n">uv_obs</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">V2</span><span class="p">,</span>
    <span class="n">K</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">Matrix33</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">Scalar</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sf</span><span class="o">.</span><span class="n">V2</span><span class="p">:</span>
    <span class="n">uv</span> <span class="o">=</span> <span class="n">K</span> <span class="o">*</span> <span class="p">(</span><span class="n">T_W_C</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span> <span class="o">*</span> <span class="n">W_t_landmark</span><span class="p">)</span>
    <span class="c1"># TODO: This is not safe, should use epsilon. And obs could go out of view.</span>
    <span class="k">return</span> <span class="n">sf</span><span class="o">.</span><span class="n">V2</span><span class="p">(</span><span class="n">uv_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">uv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">uv_obs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">uv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>


<span class="c1"># This is not using camera poses at all. If we combine this with above,</span>
<span class="c1"># It seems that we can have the pose loop constraint as well:</span>
<span class="c1"># T_B_W * T_W_C * T_C_E * T_B_E_correction.inverse()</span>
<span class="k">def</span> <span class="nf">reprojection_residual_from_arm</span><span class="p">(</span>
    <span class="n">T_B_W</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">Pose3</span><span class="p">,</span>
    <span class="n">T_B_E</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">Pose3</span><span class="p">,</span>
    <span class="n">T_B_E_position_error</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">,</span>
    <span class="n">T_C_E</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">Pose3</span><span class="p">,</span>
    <span class="n">W_t_landmark</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">,</span>
    <span class="n">uv_obs</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">V2</span><span class="p">,</span>
    <span class="n">K</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">Matrix33</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">Scalar</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sf</span><span class="o">.</span><span class="n">V2</span><span class="p">:</span>
    <span class="n">T_B_E_correction</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Pose3</span><span class="p">(</span>
        <span class="n">R</span><span class="o">=</span><span class="n">T_B_E</span><span class="o">.</span><span class="n">rotation</span><span class="p">(),</span> <span class="n">t</span><span class="o">=</span><span class="n">T_B_E_position_error</span> <span class="o">-</span> <span class="n">T_B_E</span><span class="o">.</span><span class="n">position</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">T_C_B</span> <span class="o">=</span> <span class="n">T_C_E</span> <span class="o">*</span> <span class="n">T_B_E_correction</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
    <span class="n">uv</span> <span class="o">=</span> <span class="n">K</span> <span class="o">*</span> <span class="p">(</span><span class="n">T_C_B</span> <span class="o">*</span> <span class="n">T_B_W</span> <span class="o">*</span> <span class="n">W_t_landmark</span><span class="p">)</span>
    <span class="c1"># TODO: This is not safe, should use epsilon</span>
    <span class="k">return</span> <span class="n">sf</span><span class="o">.</span><span class="n">V2</span><span class="p">(</span><span class="n">uv_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">uv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">uv_obs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">uv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">pose_loop_residual</span><span class="p">(</span>
    <span class="n">T_W_C</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">Pose3</span><span class="p">,</span>
    <span class="n">T_B_W</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">Pose3</span><span class="p">,</span>
    <span class="n">T_B_E</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">Pose3</span><span class="p">,</span>
    <span class="n">T_B_E_position_error</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">,</span>
    <span class="n">T_C_E</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">Pose3</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">sf</span><span class="o">.</span><span class="n">Scalar</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sf</span><span class="o">.</span><span class="n">V2</span><span class="p">:</span>
    <span class="n">T_B_E_correction</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Pose3</span><span class="p">(</span>
        <span class="n">R</span><span class="o">=</span><span class="n">T_B_E</span><span class="o">.</span><span class="n">rotation</span><span class="p">(),</span> <span class="n">t</span><span class="o">=</span><span class="n">T_B_E</span><span class="o">.</span><span class="n">position</span><span class="p">()</span> <span class="o">-</span> <span class="n">T_B_E_position_error</span>
    <span class="p">)</span>
    <span class="n">T_B_B</span> <span class="o">=</span> <span class="n">T_B_W</span> <span class="o">*</span> <span class="n">T_W_C</span> <span class="o">*</span> <span class="n">T_C_E</span> <span class="o">*</span> <span class="n">T_B_E_correction</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">T_B_B</span><span class="o">.</span><span class="n">to_tangent</span><span class="p">(</span><span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">)</span>


<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Generate-Factors">
    Generate Factors
    <a class="anchor-link" href="#Generate-Factors">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [111]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Generate different factors</span>


<span class="k">def</span> <span class="nf">generate_factors</span><span class="p">(</span>
    <span class="n">n_camera_poses</span><span class="p">,</span>
    <span class="n">n_world_points</span><span class="p">,</span>
    <span class="n">use_reprojection_residual_from_camera</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_reprojection_residual_from_arm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_pose_residual</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">factors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">use_reprojection_residual_from_camera</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_camera_poses</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_world_points</span><span class="p">):</span>
                <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Factor</span><span class="p">(</span>
                        <span class="n">residual</span><span class="o">=</span><span class="n">reprojection_residual_from_camera</span><span class="p">,</span>
                        <span class="n">keys</span><span class="o">=</span><span class="p">[</span>
                            <span class="sa">f</span><span class="s2">"T_W_Cs[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]"</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">"W_t_landmarks[</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">]"</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">"uv_obs[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">][</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">]"</span><span class="p">,</span>
                            <span class="s2">"K"</span><span class="p">,</span>
                            <span class="s2">"epsilon"</span><span class="p">,</span>
                        <span class="p">],</span>
                    <span class="p">)</span>
                <span class="p">)</span>
    <span class="k">if</span> <span class="n">use_reprojection_residual_from_arm</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_camera_poses</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_world_points</span><span class="p">):</span>
                <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Factor</span><span class="p">(</span>
                        <span class="n">residual</span><span class="o">=</span><span class="n">use_reprojection_residual_from_arm</span><span class="p">,</span>
                        <span class="n">keys</span><span class="o">=</span><span class="p">[</span>
                            <span class="s2">"T_B_W"</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">"T_B_Es[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]"</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">"T_B_E_position_errors[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]"</span><span class="p">,</span>
                            <span class="s2">"T_C_E"</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">"W_t_landmarks[</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">]"</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">"uv_obs[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">][</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">]"</span><span class="p">,</span>
                            <span class="s2">"K"</span><span class="p">,</span>
                            <span class="s2">"epsilon"</span><span class="p">,</span>
                        <span class="p">],</span>
                    <span class="p">)</span>
                <span class="p">)</span>
    <span class="k">if</span> <span class="n">use_pose_residual</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_camera_poses</span><span class="p">):</span>
            <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Factor</span><span class="p">(</span>
                    <span class="n">residual</span><span class="o">=</span><span class="n">pose_loop_residual</span><span class="p">,</span>
                    <span class="n">keys</span><span class="o">=</span><span class="p">[</span>
                        <span class="sa">f</span><span class="s2">"T_W_Cs[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]"</span><span class="p">,</span>
                        <span class="s2">"T_B_W"</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">"T_B_Es[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]"</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">"T_B_E_position_errors[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]"</span><span class="p">,</span>
                        <span class="s2">"T_C_E"</span><span class="p">,</span>
                        <span class="s2">"epsilon"</span><span class="p">,</span>
                    <span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">factors</span>


<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Optimize-Camera-Poses">
    Optimize Camera Poses
    <a class="anchor-link" href="#Optimize-Camera-Poses">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    The pose estimation from camera calibration appears to be quite accurate, as the residual reduction is small.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [112]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Only optimize camera poses</span>

<span class="n">uv_obs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">pixel_obs</span> <span class="ow">in</span> <span class="n">pixel_obs_list</span><span class="p">:</span>
    <span class="n">obs_per_camera</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">pixel_obs</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
        <span class="n">obs_per_camera</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">V2</span><span class="p">(</span><span class="n">obs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">obs</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">uv_obs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obs_per_camera</span><span class="p">)</span>

<span class="n">W_t_landmarks</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">world_point</span> <span class="ow">in</span> <span class="n">world_points</span><span class="p">:</span>
    <span class="n">W_t_landmarks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">(</span><span class="n">world_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">world_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">world_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

<span class="n">inputs</span> <span class="o">=</span> <span class="n">Values</span><span class="p">(</span>
    <span class="n">T_W_Cs</span><span class="o">=</span><span class="p">[</span><span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_W_C</span><span class="p">)</span> <span class="k">for</span> <span class="n">T_W_C</span> <span class="ow">in</span> <span class="n">camera_poses_tested</span><span class="p">],</span>
    <span class="n">W_t_landmarks</span><span class="o">=</span><span class="n">W_t_landmarks</span><span class="p">,</span>
    <span class="n">uv_obs</span><span class="o">=</span><span class="n">uv_obs</span><span class="p">,</span>
    <span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="o">=</span><span class="n">sf</span><span class="o">.</span><span class="n">numeric_epsilon</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">factors</span> <span class="o">=</span> <span class="n">generate_factors</span><span class="p">(</span>
    <span class="n">n_camera_poses</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">camera_poses_expected</span><span class="p">),</span>
    <span class="n">n_world_points</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">world_points</span><span class="p">),</span>
    <span class="n">use_reprojection_residual_from_camera</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">use_reprojection_residual_from_arm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_pose_residual</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">optimized_keys</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">optimized_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="sa">f</span><span class="s2">"T_W_Cs[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]"</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">camera_poses_tested</span><span class="p">))])</span>

<span class="n">optimizer</span> <span class="o">=</span> <span class="n">Optimizer</span><span class="p">(</span>
    <span class="n">factors</span><span class="o">=</span><span class="n">factors</span><span class="p">,</span>
    <span class="n">optimized_keys</span><span class="o">=</span><span class="n">optimized_keys</span><span class="p">,</span>
    <span class="c1"># So that we save more information babout each iteration, to visualize later:</span>
    <span class="n">debug_stats</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">Optimizer</span><span class="o">.</span><span class="n">Status</span><span class="o">.</span><span class="n">SUCCESS</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">iterations</span><span class="p">)</span><span class="si">=}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">initial_linearization</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">linearize</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">initial_values</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Initial error: </span><span class="si">{</span><span class="n">initial_linearization</span><span class="o">.</span><span class="n">error</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">optimized_linearization</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">linearize</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">optimized_values</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Final error: </span><span class="si">{</span><span class="n">optimized_linearization</span><span class="o">.</span><span class="n">error</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
 <div class="output_wrapper">
  <div class="output">
   <div class="output_area">
    <div class="prompt">
    </div>
    <div class="output_subarea output_stream output_stdout output_text">
     <pre>len(result.iterations)=3
Initial error: 3.4163439793428014e-21
Final error: 5.505113158739144e-25
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Optimize-End-Effector-Pose-Corrections-and-$T_%7BCE%7D$">
    Optimize End Effector Pose Corrections and $T_{CE}$
    <a class="anchor-link" href="#Optimize-End-Effector-Pose-Corrections-and-$T_%7BCE%7D$">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [122]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Optimize T_B_E_position_errors</span>

<span class="n">uv_obs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">pixel_obs</span> <span class="ow">in</span> <span class="n">pixel_obs_list</span><span class="p">:</span>
    <span class="n">obs_per_camera</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">pixel_obs</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
        <span class="n">obs_per_camera</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">V2</span><span class="p">(</span><span class="n">obs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">obs</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">uv_obs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obs_per_camera</span><span class="p">)</span>

<span class="n">W_t_landmarks</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">world_point</span> <span class="ow">in</span> <span class="n">world_points</span><span class="p">:</span>
    <span class="n">W_t_landmarks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">(</span><span class="n">world_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">world_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">world_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

<span class="n">inputs</span> <span class="o">=</span> <span class="n">Values</span><span class="p">(</span>
    <span class="n">T_W_Cs</span><span class="o">=</span><span class="p">[</span><span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_W_C</span><span class="p">)</span> <span class="k">for</span> <span class="n">T_W_C</span> <span class="ow">in</span> <span class="n">camera_poses_tested</span><span class="p">],</span>
    <span class="n">T_B_W</span><span class="o">=</span><span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_B_W_tested</span><span class="p">),</span>
    <span class="n">T_B_Es</span><span class="o">=</span><span class="p">[</span>
        <span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_B_E</span><span class="p">)</span> <span class="k">for</span> <span class="n">T_B_E</span> <span class="ow">in</span> <span class="n">end_effector_poses_noisy</span>
    <span class="p">],</span>
    <span class="n">T_B_E_position_errors</span><span class="o">=</span><span class="p">[</span><span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_effector_poses_noisy</span><span class="p">),</span>
    <span class="n">T_C_E</span><span class="o">=</span><span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_C_E_tested</span><span class="p">),</span>
    <span class="n">W_t_landmarks</span><span class="o">=</span><span class="n">W_t_landmarks</span><span class="p">,</span>
    <span class="n">uv_obs</span><span class="o">=</span><span class="n">uv_obs</span><span class="p">,</span>
    <span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="o">=</span><span class="n">sf</span><span class="o">.</span><span class="n">numeric_epsilon</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Let's just try to optimize T_C_E, and T_B_E_position_errors</span>

<span class="n">factors</span> <span class="o">=</span> <span class="n">generate_factors</span><span class="p">(</span>
    <span class="n">n_camera_poses</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">camera_poses_expected</span><span class="p">),</span>
    <span class="n">n_world_points</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">world_points</span><span class="p">),</span>
    <span class="n">use_reprojection_residual_from_camera</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_reprojection_residual_from_arm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_pose_residual</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">optimized_keys</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">optimized_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
    <span class="p">[</span><span class="sa">f</span><span class="s2">"T_B_E_position_errors[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]"</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">end_effector_poses_noisy</span><span class="p">))]</span>
<span class="p">)</span>
<span class="n">optimized_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">"T_C_E"</span><span class="p">])</span>

<span class="n">optimizer</span> <span class="o">=</span> <span class="n">Optimizer</span><span class="p">(</span>
    <span class="n">factors</span><span class="o">=</span><span class="n">factors</span><span class="p">,</span>
    <span class="n">optimized_keys</span><span class="o">=</span><span class="n">optimized_keys</span><span class="p">,</span>
    <span class="c1"># So that we save more information babout each iteration, to visualize later:</span>
    <span class="n">debug_stats</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">params</span><span class="o">=</span><span class="n">Optimizer</span><span class="o">.</span><span class="n">Params</span><span class="p">(</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">iterations</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="n">early_exit_min_reduction</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
    <span class="p">),</span>
<span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">Optimizer</span><span class="o">.</span><span class="n">Status</span><span class="o">.</span><span class="n">SUCCESS</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">iterations</span><span class="p">)</span><span class="si">=}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">initial_linearization</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">linearize</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">initial_values</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Initial error: </span><span class="si">{</span><span class="n">initial_linearization</span><span class="o">.</span><span class="n">error</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">optimized_linearization</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">linearize</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">optimized_values</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Final error: </span><span class="si">{</span><span class="n">optimized_linearization</span><span class="o">.</span><span class="n">error</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"========"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"T_CE(initial)  : "</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">initial_values</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">T_C_E</span><span class="o">.</span><span class="n">position</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"T_CE(optimized): "</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">optimized_values</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">T_C_E</span><span class="o">.</span><span class="n">position</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"T_CE(expected) : "</span><span class="p">,</span> <span class="n">T_C_E_expected</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"========"</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"expected_errors :"</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">errors_expected</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"optimized_errors:"</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">optimized_values</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">T_B_E_position_errors</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"========"</span><span class="p">)</span>

<span class="n">previous_result</span> <span class="o">=</span> <span class="n">result</span>
<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
 <div class="output_wrapper">
  <div class="output">
   <div class="output_area">
    <div class="prompt">
    </div>
    <div class="output_subarea output_stream output_stdout output_text">
     <pre>len(result.iterations)=11
Initial error: 0.005298482748792415
Final error: 1.2656542091601458e-13
========
T_CE(initial)  :  [ 0.0452 -0.0588 -0.0945]
T_CE(optimized):  [ 0.0448 -0.0458 -0.1041]
T_CE(expected) :  [ 0.0465 -0.05   -0.1017]
========
expected_errors : [array([0.0056, 0.007 , 0.0051]), array([0.0056, 0.0054, 0.006 ]), array([0.0035, 0.003 , 0.0036]), array([0.0058, 0.0054, 0.0066]), array([0.0048, 0.0043, 0.0067]), array([0.0049, 0.0062, 0.0038]), array([0.0063, 0.0036, 0.0057]), array([0.0032, 0.0061, 0.0059]), array([0.0061, 0.0037, 0.0032]), array([0.0066, 0.0037, 0.0061]), array([0.0041, 0.0056, 0.007 ]), array([0.0041, 0.0047, 0.0061]), array([0.004 , 0.0032, 0.0065]), array([0.004 , 0.0046, 0.0042]), array([0.0069, 0.0053, 0.0041]), array([0.0065, 0.0033, 0.0061]), array([0.0056, 0.0038, 0.006 ]), array([0.0068, 0.006 , 0.0057]), array([0.0054, 0.0038, 0.0047]), array([0.0062, 0.006 , 0.0058]), array([0.0034, 0.0063, 0.005 ]), array([0.0052, 0.005 , 0.0049]), array([0.0034, 0.0065, 0.0037]), array([0.0044, 0.0038, 0.0051]), array([0.0066, 0.0041, 0.0059]), array([0.0061, 0.003 , 0.0064]), array([0.0058, 0.0057, 0.0039]), array([0.0052, 0.0069, 0.0039]), array([0.0062, 0.0034, 0.0058]), array([0.0036, 0.0041, 0.0069]), array([0.0069, 0.0036, 0.0068]), array([0.0064, 0.0069, 0.0044])]
optimized_errors: [array([0.004 , 0.007 , 0.0002]), array([0.004 , 0.0046, 0.0012]), array([ 0.0019,  0.0014, -0.001 ]), array([0.0042, 0.0029, 0.0023]), array([0.0056, 0.0028, 0.0018]), array([ 0.0064,  0.0052, -0.001 ]), array([0.0085, 0.003 , 0.0011]), array([0.0062, 0.0059, 0.0017]), array([ 0.0069,  0.0052, -0.0017]), array([0.0066, 0.0055, 0.0013]), array([0.0035, 0.0079, 0.0023]), array([0.0028, 0.0073, 0.0018]), array([0.0024, 0.0032, 0.0016]), array([ 0.0024,  0.0038, -0.0006]), array([ 0.0053,  0.0036, -0.0005]), array([0.0049, 0.0009, 0.0018]), array([0.0039, 0.0038, 0.0011]), array([0.0052, 0.0052, 0.0009]), array([3.7438e-03, 2.0942e-03, 9.9781e-05]), array([0.0046, 0.0036, 0.0016]), array([4.2196e-03, 4.9197e-03, 9.1918e-05]), array([6.7145e-03, 3.9874e-03, 3.2584e-05]), array([ 0.0056,  0.0059, -0.0009]), array([0.0073, 0.0036, 0.0009]), array([0.0074, 0.0055, 0.001 ]), array([0.0062, 0.0049, 0.0016]), array([ 0.0052,  0.008 , -0.0007]), array([ 0.0039,  0.0096, -0.0003]), array([0.0046, 0.0034, 0.0009]), array([0.0019, 0.0033, 0.0021]), array([0.0053, 0.0019, 0.0022]), array([0.0048, 0.0044, 0.0002])]
========
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Optimize-End-Effector-Pose-Corrections">
    Optimize End Effector Pose Corrections
    <a class="anchor-link" href="#Optimize-End-Effector-Pose-Corrections">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Now, let's focus on optimizing the end-effector pose correction $T_{E_nE}$. The relative error reduction is significant, even though the absolute system error with the initial value is quite small (we have perfect measurements).
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [136]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Optimize T_B_E_position_errors</span>

<span class="n">uv_obs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">pixel_obs</span> <span class="ow">in</span> <span class="n">pixel_obs_list</span><span class="p">:</span>
    <span class="n">obs_per_camera</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">pixel_obs</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
        <span class="n">obs_per_camera</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">V2</span><span class="p">(</span><span class="n">obs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">obs</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">uv_obs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obs_per_camera</span><span class="p">)</span>

<span class="n">W_t_landmarks</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">world_point</span> <span class="ow">in</span> <span class="n">world_points</span><span class="p">:</span>
    <span class="n">W_t_landmarks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">(</span><span class="n">world_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">world_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">world_point</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

<span class="n">inputs</span> <span class="o">=</span> <span class="n">Values</span><span class="p">(</span>
    <span class="n">T_W_Cs</span><span class="o">=</span><span class="p">[</span><span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_W_C</span><span class="p">)</span> <span class="k">for</span> <span class="n">T_W_C</span> <span class="ow">in</span> <span class="n">camera_poses_tested</span><span class="p">],</span>
    <span class="n">T_B_W</span><span class="o">=</span><span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_B_W_tested</span><span class="p">),</span>
    <span class="n">T_B_Es</span><span class="o">=</span><span class="p">[</span>
        <span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_B_E</span><span class="p">)</span> <span class="k">for</span> <span class="n">T_B_E</span> <span class="ow">in</span> <span class="n">end_effector_poses_noisy</span>
    <span class="p">],</span>
    <span class="n">T_B_E_position_errors</span><span class="o">=</span><span class="p">[</span><span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_effector_poses_noisy</span><span class="p">),</span>
    <span class="n">T_C_E</span><span class="o">=</span><span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_C_E_tested</span><span class="p">),</span>
    <span class="n">W_t_landmarks</span><span class="o">=</span><span class="n">W_t_landmarks</span><span class="p">,</span>
    <span class="n">uv_obs</span><span class="o">=</span><span class="n">uv_obs</span><span class="p">,</span>
    <span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="o">=</span><span class="n">sf</span><span class="o">.</span><span class="n">numeric_epsilon</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">factors</span> <span class="o">=</span> <span class="n">generate_factors</span><span class="p">(</span>
    <span class="n">n_camera_poses</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">camera_poses_expected</span><span class="p">),</span>
    <span class="n">n_world_points</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">world_points</span><span class="p">),</span>
    <span class="n">use_reprojection_residual_from_camera</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_reprojection_residual_from_arm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_pose_residual</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">optimized_keys</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">optimized_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
    <span class="p">[</span><span class="sa">f</span><span class="s2">"T_B_E_position_errors[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]"</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">end_effector_poses_noisy</span><span class="p">))]</span>
<span class="p">)</span>

<span class="n">optimizer</span> <span class="o">=</span> <span class="n">Optimizer</span><span class="p">(</span>
    <span class="n">factors</span><span class="o">=</span><span class="n">factors</span><span class="p">,</span>
    <span class="n">optimized_keys</span><span class="o">=</span><span class="n">optimized_keys</span><span class="p">,</span>
    <span class="c1"># So that we save more information babout each iteration, to visualize later:</span>
    <span class="n">debug_stats</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">Optimizer</span><span class="o">.</span><span class="n">Status</span><span class="o">.</span><span class="n">SUCCESS</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">iterations</span><span class="p">)</span><span class="si">=}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">initial_linearization</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">linearize</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">initial_values</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Initial error: </span><span class="si">{</span><span class="n">initial_linearization</span><span class="o">.</span><span class="n">error</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">optimized_linearization</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">linearize</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">optimized_values</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Final error: </span><span class="si">{</span><span class="n">optimized_linearization</span><span class="o">.</span><span class="n">error</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"========"</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"expected_errors :"</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">errors_expected</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"optimized_errors:"</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">optimized_values</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">T_B_E_position_errors</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"========"</span><span class="p">)</span>

<span class="n">previous_result</span> <span class="o">=</span> <span class="n">result</span>
<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
 <div class="output_wrapper">
  <div class="output">
   <div class="output_area">
    <div class="prompt">
    </div>
    <div class="output_subarea output_stream output_stdout output_text">
     <pre>len(result.iterations)=8
Initial error: 0.005298482748792109
Final error: 3.1803870859392485e-13
========
expected_errors : [array([0.0056, 0.007 , 0.0051]), array([0.0056, 0.0054, 0.006 ]), array([0.0035, 0.003 , 0.0036]), array([0.0058, 0.0054, 0.0066]), array([0.0048, 0.0043, 0.0067]), array([0.0049, 0.0062, 0.0038]), array([0.0063, 0.0036, 0.0057]), array([0.0032, 0.0061, 0.0059]), array([0.0061, 0.0037, 0.0032]), array([0.0066, 0.0037, 0.0061]), array([0.0041, 0.0056, 0.007 ]), array([0.0041, 0.0047, 0.0061]), array([0.004 , 0.0032, 0.0065]), array([0.004 , 0.0046, 0.0042]), array([0.0069, 0.0053, 0.0041]), array([0.0065, 0.0033, 0.0061]), array([0.0056, 0.0038, 0.006 ]), array([0.0068, 0.006 , 0.0057]), array([0.0054, 0.0038, 0.0047]), array([0.0062, 0.006 , 0.0058]), array([0.0034, 0.0063, 0.005 ]), array([0.0052, 0.005 , 0.0049]), array([0.0034, 0.0065, 0.0037]), array([0.0044, 0.0038, 0.0051]), array([0.0066, 0.0041, 0.0059]), array([0.0061, 0.003 , 0.0064]), array([0.0058, 0.0057, 0.0039]), array([0.0052, 0.0069, 0.0039]), array([0.0062, 0.0034, 0.0058]), array([0.0036, 0.0041, 0.0069]), array([0.0069, 0.0036, 0.0068]), array([0.0064, 0.0069, 0.0044])]
optimized_errors: [array([0.0043, 0.0052, 0.0163]), array([0.0043, 0.0055, 0.0173]), array([0.0023, 0.0051, 0.0147]), array([0.0045, 0.0094, 0.0172]), array([0.007 , 0.0041, 0.0179]), array([0.0054, 0.005 , 0.0151]), array([0.0051, 0.0014, 0.0169]), array([0.0004, 0.003 , 0.0165]), array([0.0052, 0.0058, 0.0144]), array([0.0073, 0.0047, 0.0174]), array([0.0066, 0.0057, 0.0181]), array([0.0082, 0.0038, 0.0167]), array([0.0027, 0.0014, 0.0176]), array([0.0027, 0.0048, 0.0156]), array([0.0056, 0.0074, 0.0152]), array([0.0052, 0.0073, 0.0167]), array([0.0043, 0.002 , 0.0172]), array([0.0055, 0.0062, 0.017 ]), array([0.0041, 0.0059, 0.0158]), array([0.005 , 0.0101, 0.0164]), array([0.0056, 0.0061, 0.0162]), array([0.0057, 0.0038, 0.0162]), array([0.0022, 0.0043, 0.0148]), array([0.0016, 0.0006, 0.0157]), array([0.0057, 0.0061, 0.0171]), array([0.0069, 0.0041, 0.0177]), array([0.0083, 0.0058, 0.015 ]), array([0.0094, 0.006 , 0.0145]), array([0.0049, 0.0016, 0.017 ]), array([0.0023, 0.0043, 0.0182]), array([0.0056, 0.0057, 0.018 ]), array([0.0051, 0.0109, 0.015 ])]
========
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Optimize-End-Effector-Pose-Corrections-and-$T_%7BCE%7D$-again">
    Optimize End Effector Pose Corrections and $T_{CE}$ again
    <a class="anchor-link" href="#Optimize-End-Effector-Pose-Corrections-and-$T_%7BCE%7D$-again">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    After getting end-effector pose correction $T_{E_nE}$, I try to optimize both $T_{E_nE}$ and $T_{CE}$. Interestingly, there is no movement of $T_{CE}$ but just $T_{E_nE}$.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [137]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Let's just try to optimize T_C_E and T_B_E_position_errors</span>

<span class="n">T_B_E_position_errors</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">(</span><span class="n">error</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">error</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">error</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">previous_result</span><span class="o">.</span><span class="n">optimized_values</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">T_B_E_position_errors</span>
<span class="p">]</span>

<span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
    <span class="n">T_B_E_position_errors</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">(</span><span class="n">error</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">error</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">error</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">errors_expected</span>
    <span class="p">]</span>

<span class="n">inputs</span> <span class="o">=</span> <span class="n">Values</span><span class="p">(</span>
    <span class="n">T_W_Cs</span><span class="o">=</span><span class="p">[</span><span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_W_C</span><span class="p">)</span> <span class="k">for</span> <span class="n">T_W_C</span> <span class="ow">in</span> <span class="n">camera_poses_tested</span><span class="p">],</span>
    <span class="n">T_B_W</span><span class="o">=</span><span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_B_W_tested</span><span class="p">),</span>
    <span class="n">T_B_Es</span><span class="o">=</span><span class="p">[</span>
        <span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_B_E</span><span class="p">)</span> <span class="k">for</span> <span class="n">T_B_E</span> <span class="ow">in</span> <span class="n">end_effector_poses_noisy</span>
    <span class="p">],</span>
    <span class="n">T_B_E_position_errors</span><span class="o">=</span><span class="n">T_B_E_position_errors</span><span class="p">,</span>
    <span class="n">T_C_E</span><span class="o">=</span><span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_C_E_tested</span><span class="p">),</span>
    <span class="n">W_t_landmarks</span><span class="o">=</span><span class="n">W_t_landmarks</span><span class="p">,</span>
    <span class="n">uv_obs</span><span class="o">=</span><span class="n">uv_obs</span><span class="p">,</span>
    <span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="o">=</span><span class="n">sf</span><span class="o">.</span><span class="n">numeric_epsilon</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">factors</span> <span class="o">=</span> <span class="n">generate_factors</span><span class="p">(</span>
    <span class="n">n_camera_poses</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">camera_poses_expected</span><span class="p">),</span>
    <span class="n">n_world_points</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">world_points</span><span class="p">),</span>
    <span class="n">use_reprojection_residual_from_camera</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_reprojection_residual_from_arm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_pose_residual</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">optimized_keys</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">optimized_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
    <span class="p">[</span><span class="sa">f</span><span class="s2">"T_B_E_position_errors[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]"</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">end_effector_poses_noisy</span><span class="p">))]</span>
<span class="p">)</span>
<span class="n">optimized_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">"T_C_E"</span><span class="p">])</span>

<span class="n">optimizer</span> <span class="o">=</span> <span class="n">Optimizer</span><span class="p">(</span>
    <span class="n">factors</span><span class="o">=</span><span class="n">factors</span><span class="p">,</span>
    <span class="n">optimized_keys</span><span class="o">=</span><span class="n">optimized_keys</span><span class="p">,</span>
    <span class="c1"># So that we save more information babout each iteration, to visualize later:</span>
    <span class="n">debug_stats</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">Optimizer</span><span class="o">.</span><span class="n">Status</span><span class="o">.</span><span class="n">SUCCESS</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">iterations</span><span class="p">)</span><span class="si">=}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">initial_linearization</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">linearize</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">initial_values</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Initial error: </span><span class="si">{</span><span class="n">initial_linearization</span><span class="o">.</span><span class="n">error</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">optimized_linearization</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">linearize</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">optimized_values</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Final error: </span><span class="si">{</span><span class="n">optimized_linearization</span><span class="o">.</span><span class="n">error</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"========"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"T_CE(initial)  : "</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">initial_values</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">T_C_E</span><span class="o">.</span><span class="n">position</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"T_CE(optimized): "</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">optimized_values</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">T_C_E</span><span class="o">.</span><span class="n">position</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"T_CE(expected) : "</span><span class="p">,</span> <span class="n">T_C_E_expected</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"========"</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"expected_errors :"</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">errors_expected</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"optimized_errors:"</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">optimized_values</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">T_B_E_position_errors</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"========"</span><span class="p">)</span>

<span class="n">previous_result</span> <span class="o">=</span> <span class="n">result</span>
<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
 <div class="output_wrapper">
  <div class="output">
   <div class="output_area">
    <div class="prompt">
    </div>
    <div class="output_subarea output_stream output_stdout output_text">
     <pre>len(result.iterations)=10
Initial error: 3.180387086041939e-13
Final error: 1.2656542081530388e-13
========
T_CE(initial)  :  [ 0.0452 -0.0588 -0.0945]
T_CE(optimized):  [ 0.0452 -0.0588 -0.0945]
T_CE(expected) :  [ 0.0465 -0.05   -0.1017]
========
expected_errors : [array([0.0056, 0.007 , 0.0051]), array([0.0056, 0.0054, 0.006 ]), array([0.0035, 0.003 , 0.0036]), array([0.0058, 0.0054, 0.0066]), array([0.0048, 0.0043, 0.0067]), array([0.0049, 0.0062, 0.0038]), array([0.0063, 0.0036, 0.0057]), array([0.0032, 0.0061, 0.0059]), array([0.0061, 0.0037, 0.0032]), array([0.0066, 0.0037, 0.0061]), array([0.0041, 0.0056, 0.007 ]), array([0.0041, 0.0047, 0.0061]), array([0.004 , 0.0032, 0.0065]), array([0.004 , 0.0046, 0.0042]), array([0.0069, 0.0053, 0.0041]), array([0.0065, 0.0033, 0.0061]), array([0.0056, 0.0038, 0.006 ]), array([0.0068, 0.006 , 0.0057]), array([0.0054, 0.0038, 0.0047]), array([0.0062, 0.006 , 0.0058]), array([0.0034, 0.0063, 0.005 ]), array([0.0052, 0.005 , 0.0049]), array([0.0034, 0.0065, 0.0037]), array([0.0044, 0.0038, 0.0051]), array([0.0066, 0.0041, 0.0059]), array([0.0061, 0.003 , 0.0064]), array([0.0058, 0.0057, 0.0039]), array([0.0052, 0.0069, 0.0039]), array([0.0062, 0.0034, 0.0058]), array([0.0036, 0.0041, 0.0069]), array([0.0069, 0.0036, 0.0068]), array([0.0064, 0.0069, 0.0044])]
optimized_errors: [array([0.0043, 0.0052, 0.0163]), array([0.0043, 0.0055, 0.0173]), array([0.0023, 0.0051, 0.0147]), array([0.0045, 0.0094, 0.0172]), array([0.007 , 0.0041, 0.0179]), array([0.0054, 0.005 , 0.0151]), array([0.0051, 0.0014, 0.0169]), array([0.0004, 0.003 , 0.0165]), array([0.0052, 0.0058, 0.0144]), array([0.0073, 0.0047, 0.0174]), array([0.0066, 0.0057, 0.0181]), array([0.0082, 0.0038, 0.0167]), array([0.0027, 0.0014, 0.0176]), array([0.0027, 0.0048, 0.0156]), array([0.0056, 0.0074, 0.0152]), array([0.0052, 0.0073, 0.0167]), array([0.0043, 0.002 , 0.0172]), array([0.0055, 0.0062, 0.017 ]), array([0.0041, 0.0059, 0.0158]), array([0.005 , 0.0101, 0.0164]), array([0.0056, 0.0061, 0.0162]), array([0.0057, 0.0038, 0.0162]), array([0.0022, 0.0043, 0.0148]), array([0.0016, 0.0006, 0.0157]), array([0.0057, 0.0061, 0.0171]), array([0.0069, 0.0041, 0.0177]), array([0.0083, 0.0058, 0.015 ]), array([0.0094, 0.006 , 0.0145]), array([0.0049, 0.0016, 0.017 ]), array([0.0023, 0.0043, 0.0182]), array([0.0056, 0.0057, 0.018 ]), array([0.0051, 0.0109, 0.015 ])]
========
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [138]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Let's just try to optimize T_C_E and T_B_E_position_errors (Cheat on initial guesses)</span>

<span class="n">T_B_E_position_errors</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">(</span><span class="n">error</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">error</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">error</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">previous_result</span><span class="o">.</span><span class="n">optimized_values</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">T_B_E_position_errors</span>
<span class="p">]</span>

<span class="k">if</span> <span class="kc">True</span><span class="p">:</span>  <span class="c1"># Cheating... :-)</span>
    <span class="n">T_B_E_position_errors</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">sf</span><span class="o">.</span><span class="n">V3</span><span class="p">(</span><span class="n">error</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">error</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">error</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">errors_expected</span>
    <span class="p">]</span>

<span class="n">inputs</span> <span class="o">=</span> <span class="n">Values</span><span class="p">(</span>
    <span class="n">T_W_Cs</span><span class="o">=</span><span class="p">[</span><span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_W_C</span><span class="p">)</span> <span class="k">for</span> <span class="n">T_W_C</span> <span class="ow">in</span> <span class="n">camera_poses_tested</span><span class="p">],</span>
    <span class="n">T_B_W</span><span class="o">=</span><span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_B_W_tested</span><span class="p">),</span>
    <span class="n">T_B_Es</span><span class="o">=</span><span class="p">[</span>
        <span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_B_E</span><span class="p">)</span> <span class="k">for</span> <span class="n">T_B_E</span> <span class="ow">in</span> <span class="n">end_effector_poses_noisy</span>
    <span class="p">],</span>
    <span class="n">T_B_E_position_errors</span><span class="o">=</span><span class="n">T_B_E_position_errors</span><span class="p">,</span>
    <span class="n">T_C_E</span><span class="o">=</span><span class="n">symforce_from_projection_matrix</span><span class="p">(</span><span class="n">T_C_E_tested</span><span class="p">),</span>
    <span class="n">W_t_landmarks</span><span class="o">=</span><span class="n">W_t_landmarks</span><span class="p">,</span>
    <span class="n">uv_obs</span><span class="o">=</span><span class="n">uv_obs</span><span class="p">,</span>
    <span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="o">=</span><span class="n">sf</span><span class="o">.</span><span class="n">numeric_epsilon</span><span class="p">,</span>
<span class="p">)</span>


<span class="n">factors</span> <span class="o">=</span> <span class="n">generate_factors</span><span class="p">(</span>
    <span class="n">n_camera_poses</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">camera_poses_expected</span><span class="p">),</span>
    <span class="n">n_world_points</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">world_points</span><span class="p">),</span>
    <span class="n">use_reprojection_residual_from_camera</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_reprojection_residual_from_arm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">use_pose_residual</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">optimized_keys</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">optimized_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
    <span class="p">[</span><span class="sa">f</span><span class="s2">"T_B_E_position_errors[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]"</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">end_effector_poses_noisy</span><span class="p">))]</span>
<span class="p">)</span>
<span class="n">optimized_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">"T_C_E"</span><span class="p">])</span>

<span class="n">optimizer</span> <span class="o">=</span> <span class="n">Optimizer</span><span class="p">(</span>
    <span class="n">factors</span><span class="o">=</span><span class="n">factors</span><span class="p">,</span>
    <span class="n">optimized_keys</span><span class="o">=</span><span class="n">optimized_keys</span><span class="p">,</span>
    <span class="c1"># So that we save more information babout each iteration, to visualize later:</span>
    <span class="n">debug_stats</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">Optimizer</span><span class="o">.</span><span class="n">Status</span><span class="o">.</span><span class="n">SUCCESS</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">iterations</span><span class="p">)</span><span class="si">=}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">initial_linearization</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">linearize</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">initial_values</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Initial error: </span><span class="si">{</span><span class="n">initial_linearization</span><span class="o">.</span><span class="n">error</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">optimized_linearization</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">linearize</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">optimized_values</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Final error: </span><span class="si">{</span><span class="n">optimized_linearization</span><span class="o">.</span><span class="n">error</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"========"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"T_CE(initial)  : "</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">initial_values</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">T_C_E</span><span class="o">.</span><span class="n">position</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"T_CE(optimized): "</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">optimized_values</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">T_C_E</span><span class="o">.</span><span class="n">position</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"T_CE(expected) : "</span><span class="p">,</span> <span class="n">T_C_E_expected</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"========"</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"expected_errors :"</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">errors_expected</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"optimized_errors:"</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">optimized_values</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">T_B_E_position_errors</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"========"</span><span class="p">)</span>
<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
 <div class="output_wrapper">
  <div class="output">
   <div class="output_area">
    <div class="prompt">
    </div>
    <div class="output_subarea output_stream output_stdout output_text">
     <pre>len(result.iterations)=11
Initial error: 0.0020829916578865106
Final error: 1.2656542085960234e-13
========
T_CE(initial)  :  [ 0.0452 -0.0588 -0.0945]
T_CE(optimized):  [ 0.0464 -0.0503 -0.1015]
T_CE(expected) :  [ 0.0465 -0.05   -0.1017]
========
expected_errors : [array([0.0056, 0.007 , 0.0051]), array([0.0056, 0.0054, 0.006 ]), array([0.0035, 0.003 , 0.0036]), array([0.0058, 0.0054, 0.0066]), array([0.0048, 0.0043, 0.0067]), array([0.0049, 0.0062, 0.0038]), array([0.0063, 0.0036, 0.0057]), array([0.0032, 0.0061, 0.0059]), array([0.0061, 0.0037, 0.0032]), array([0.0066, 0.0037, 0.0061]), array([0.0041, 0.0056, 0.007 ]), array([0.0041, 0.0047, 0.0061]), array([0.004 , 0.0032, 0.0065]), array([0.004 , 0.0046, 0.0042]), array([0.0069, 0.0053, 0.0041]), array([0.0065, 0.0033, 0.0061]), array([0.0056, 0.0038, 0.006 ]), array([0.0068, 0.006 , 0.0057]), array([0.0054, 0.0038, 0.0047]), array([0.0062, 0.006 , 0.0058]), array([0.0034, 0.0063, 0.005 ]), array([0.0052, 0.005 , 0.0049]), array([0.0034, 0.0065, 0.0037]), array([0.0044, 0.0038, 0.0051]), array([0.0066, 0.0041, 0.0059]), array([0.0061, 0.003 , 0.0064]), array([0.0058, 0.0057, 0.0039]), array([0.0052, 0.0069, 0.0039]), array([0.0062, 0.0034, 0.0058]), array([0.0036, 0.0041, 0.0069]), array([0.0069, 0.0036, 0.0068]), array([0.0064, 0.0069, 0.0044])]
optimized_errors: [array([0.0056, 0.0069, 0.0054]), array([0.0056, 0.0054, 0.0064]), array([0.0035, 0.0031, 0.0039]), array([0.0058, 0.0055, 0.0069]), array([0.0048, 0.0043, 0.007 ]), array([0.0049, 0.0062, 0.0041]), array([0.0062, 0.0035, 0.0061]), array([0.0031, 0.006 , 0.0063]), array([0.0061, 0.0038, 0.0035]), array([0.0066, 0.0037, 0.0064]), array([0.0042, 0.0056, 0.0073]), array([0.0042, 0.0046, 0.0064]), array([0.004 , 0.0032, 0.0068]), array([0.004 , 0.0046, 0.0046]), array([0.0068, 0.0054, 0.0044]), array([0.0064, 0.0034, 0.0064]), array([0.0055, 0.0037, 0.0063]), array([0.0068, 0.006 , 0.006 ]), array([0.0053, 0.0038, 0.005 ]), array([0.0062, 0.0062, 0.0062]), array([0.0035, 0.0063, 0.0053]), array([0.0052, 0.0049, 0.0052]), array([0.0033, 0.0064, 0.004 ]), array([0.0043, 0.0037, 0.0054]), array([0.0066, 0.0042, 0.0062]), array([0.0061, 0.0031, 0.0067]), array([0.0059, 0.0057, 0.0042]), array([0.0054, 0.0069, 0.0043]), array([0.0062, 0.0034, 0.0061]), array([0.0035, 0.0042, 0.0072]), array([0.0068, 0.0037, 0.0072]), array([0.0064, 0.007 , 0.0048])]
========
</pre>
    </div>
   </div>
  </div>
 </div>
</div>

<div> This blog is converted from <a href="https://github.com/xipengwang/xipengwang.github.io/tree/master/notebooks/hand_eye.ipynb">hand_eye.ipynb</a></div>