---
layout: notebook
title: Inertial Navigation System
description: Inertial Navigation System
tag: Notebook
---

<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h2 id="Coordinate-Frames">
    Coordinate Frames
    <a class="anchor-link" href="#Coordinate-Frames">
     ¶
    </a>
   </h2>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    <strong>
     The body frame b
    </strong>
    is the coordinate frame of the moving IMU. Its origin is located in the center of the accelerometer triad and it is aligned to the casing. All the inertial measurements are resolved in this frame.
   </p>
   <p>
    <strong>
     The local navigation frame n
    </strong>
    is a local geographic frame in which we want to navigate. We are interested in the position and orientation of the
    <strong>
     b-frame
    </strong>
    with respect to this
    <strong>
     n-frame
    </strong>
    .
   </p>
   <p>
    <strong>
     The inertial frame i
    </strong>
    is a stationary frame. The IMU measures linear acceleration and angular velocity with respect to this frame. Its origin is located at the center of the earth and its axes are aligned with respect to the stars.
   </p>
   <p>
    <strong>
     The earth (ECEF) frame e
    </strong>
    coincides with the i-frame, but rotates with the earth. That is, it has its origin at the center of the earth and axes which are fixed with respect to the earth.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h2 id="IMU-measurements">
    IMU measurements
    <a class="anchor-link" href="#IMU-measurements">
     ¶
    </a>
   </h2>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Angular-Velocity">
    Angular Velocity
    <a class="anchor-link" href="#Angular-Velocity">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    The gyroscope measures the angular velocity of the body frame with respect to the inertial frame, expressed in the body frame denoted by $\omega_{ib}^b$ . 
$$
\begin{align}
\omega_{ib}^b = R^{bn}(\omega_{ie}^n + \omega_{en}^n) + \omega_{nb}^b
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    where $R^{bn}$ is a rotation matrix from local navigation frame to body frame. $\omega_{ie}^n$ is the earth rotating rate with respected to inertial frame expressed in local navigation frame, which is about $7.29*10^{−5}\ \text{rad/s}$. $\omega_{en}^n$ is 0 if the local navigation system is defined stationary on the earth.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Linear--Acceleration">
    Linear  Acceleration
    <a class="anchor-link" href="#Linear--Acceleration">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    The accelerometer measures the specific force $a^b$ in the body frame.
$$
\begin{align}
a_{ii}^b = R^{bn}(a_{ii}^n - g^n)
\end{align}
$$
where $g$ is the gravity vector expressed in local navigation frame, and $a_{ii}^n$ is the linear acceleration expressed in local navigation frame.
$$
\begin{align}
a_{ii}^n = R^{ni}a_{ii}^i
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    The velocity and acceleration can be obtained by differentiation in a corresponding frame as:
$$
\begin{align}
\frac{\partial}{\partial{t}}p^n|_n = v_n^n \\ 
\frac{\partial}{\partial{t}}v^n|_n = a_{nn}^n \\
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    <strong>
     Concept Review
    </strong>
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Suppose we have a frame v is only rotating with respect to frame u, then in general we have:
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   $$
\begin{align}
\frac{\partial}{\partial{t}}x^u|_u &amp;= \frac{\partial}{\partial{t}}R^{uv}x^v|_u \\
&amp;= R^{uv}\frac{\partial}{\partial{t}}x^v|_v + \frac{\partial}{\partial{t}}R^{uv}x^v \\
&amp;= R^{uv}\frac{\partial}{\partial{t}}x^v|_v + [\omega_{uv}^{u}]_{\times}R^{uv}x^v \\
&amp;= R^{uv}\frac{\partial}{\partial{t}}x^v|_v + [\omega_{uv}^{u}]_{\times}x^u
\end{align}
$$
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   $$
\begin{align}
\frac{\partial}{\partial{t}}x^u|_u &amp;= \frac{\partial}{\partial{t}}R^{uv}x^v|_u \\
&amp;= R^{uv}\frac{\partial}{\partial{t}}x^v|_v + \frac{\partial}{\partial{t}}R^{uv}x^v \\
&amp;= R^{uv}\frac{\partial}{\partial{t}}x^v|_v + R^{uv}[\omega_{uv}^{v}]_{\times}x^v \\
&amp;= R^{uv}(\frac{\partial}{\partial{t}}x^v|_v + [\omega_{uv}^{v}]_{\times}x^v)
\end{align}
$$
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Suppose we have a frame v is rotating and moving with respect to frame u, then in general we have:
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   $$
\begin{align}
\frac{\partial}{\partial{t}}x^u|_u &amp;= \frac{\partial}{\partial{t}}(R^{uv}x^v+r_{uv}^u)|_u \\
&amp;= R^{uv}\frac{\partial}{\partial{t}}x^v|_v + \frac{\partial}{\partial{t}}R^{uv}x^v + \frac{\partial}{\partial{t}}r_{uv}^u|_u\\
&amp;= R^{uv}\frac{\partial}{\partial{t}}x^v|_v + R^{uv}[\omega_{uv}^{v}]_{\times}x^v + \frac{\partial}{\partial{t}}r_{uv}^u|_u\\
&amp;= R^{uv}(\frac{\partial}{\partial{t}}x^v|_v + [\omega_{uv}^{v}]_{\times}x^v) + \frac{\partial}{\partial{t}}r_{uv}^u|_u
\end{align}
$$
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    where $\frac{\partial}{\partial{t}}r_{uv}^u|_u$ is the moving speed, $\omega_{uv}^{v}$ is angular velocity expressed in the moving frame $v$.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    So suppose b frame, e.g. earth frame, is rotating with respect g frame, e.g. inertial frame, but without any translation, given $v = [\omega]_{\times}r $, then for a point $p$ in frame b, we have its velocity and acceleration expressed in frame g as:
$$
\begin{align}
v^g_{g} &amp;= R^{gb}(v^b_{b} +[\omega_{gb}^b]_{\times}r_{o^{b}p}^b) \\
a^g_{gg} &amp;= R^{gb}(a^b_{bb} + \dot{\omega}_{gb}^b + 2[\omega_{gb}^b]_{\times}v^b_{b} + [\omega_{gb}^b]_{\times}([\omega_{gb}^b]_{\times}r_{o^{b}p}^b))
\end{align}
$$
where $\dot{\omega}_{gb}^b$ is angular acceleration, $2[\omega_{gb}^b]_{\times}v^b_{b}$ is Coriolis acceleration, $[\omega_{gb}^b]_{\times}([\omega_{gb}^b]_{\times}r_{o^{b}p}^b$ is Centripetal acceleration.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Since earth frame is only rotating around the inertial frame, so we can get:
$$
\begin{align}
v_{i}^i &amp;= R^{ie}(v_e^e +  [\omega_{ie}^e]_{\times}r_{o^{e}p}^e)\\
&amp;=v^i_e + [\omega_{ie}^i]_{\times}r_{o^{e}p}^i\\
a_{ii}^i &amp;= R^{ie}(a_{ee}^e + + \dot{\omega}_{ie}^e + 2[\omega_{ie}^e]_{\times}v^e_{e} + [\omega_{ie}^e]_{\times}([\omega_{ie}^e]_{\times}r_{o^{e}p}^e))\\
&amp;= a^i_{ee} + 0 + 2[\omega_{ie}^i]_{\times}v_e^i + [\omega_{ie}^i]_{\times}([\omega_{ie}^i]_{\times}r_{o^{e}p}^i)
\end{align}
$$
where we assume the angular velocity of the earth is constant, i.e. $\dot{\omega}_{ie}^e = 0$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Similarly, we can get the velocity and acceleration relation between earth frame and navigation frame where we assume navigation frame is stationary with respect to the earth frame, i.e. $[\omega_{en}^n] = 0$: 
$$
\begin{align}
v_{e}^e &amp;= R^{en}(v_n^n +  [\omega_{en}^n]_{\times}r_{o^{n}p}^n)\\
&amp;=v^e_n \\
v_e^n &amp;= R^{ne}v_n^e = v_n^n \\
a_{ee}^e &amp;= R^{en}(a_{nn}^n + + \dot{\omega}_{en}^e + 2[\omega_{en}^n]_{\times}v^n_{n} + [\omega_{en}^n]_{\times}([\omega_{en}^n]_{\times}r_{o^{n}p}^n))\\
&amp;= a^e_{nn} \\
a_{ee}^n &amp;= R^{ne}a_{nn}^e = a_{nn}^n
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Because we have:
$$
\begin{align}
v_e^n &amp;= R^{ne}v_n^e = v_n^n \\
a_{ee}^n &amp;= R^{ne}a_{nn}^e = a_{nn}^n
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    <strong>
     Finally, we get an important equation:
    </strong>
    $$
\begin{align}
a_{ii}^n &amp;= R^{ni}a_{ii}^i \\
&amp; = R^{ni}(a^i_{ee} + 0 + 2[\omega_{ie}^i]_{\times}v_e^i + [\omega_{ie}^i]_{\times}([\omega_{ie}^i]_{\times}r_{o^{e}p}^i)) \\
&amp; = a^n_{ee} + 2[\omega_{ie}^n]_{\times}v_e^n + [\omega_{ie}^n]_{\times}([\omega_{ie}^n]_{\times}r_{o^{e}p}^n)\\
&amp; = a^n_{nn} + 2[\omega_{ie}^n]_{\times}v_n^n + [\omega_{ie}^n]_{\times}([\omega_{ie}^n]_{\times}r_{o^{e}p}^n)
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Recall that we have the measurement model as:
 $$
\begin{align}
a^b = R^{bn}(a_{ii}^n - g^n)
\end{align}
$$
So we can get a correlation between the measurement $a^b$ and the acceleration state $a^n_{nn}$ in local navigation frame.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Normally, because Centrifugal acceleration is small in the order of $10^{−2}\ m/s^2$ given earth rotation is about $7.29*10^{−5}\ \text{rad}/s$. For Coriolis acceleration, when car travel 80 miles per hour, it is in the order of $10^{−3}\ m/s^2$.
    <strong>
     So we can normally use
    </strong>
    $a_{ii}^n = a_{nn}^n$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    <strong>
     So we have the measurement model as:
    </strong>
    Recall that we have the measurement model as:
$$
\begin{align}
a^b = R^{bn}(a_{nn}^n - g^n)
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Measurement-Model">
    Measurement Model
    <a class="anchor-link" href="#Measurement-Model">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h4 id="Gyroscope-measurement-models">
    Gyroscope measurement models
    <a class="anchor-link" href="#Gyroscope-measurement-models">
     ¶
    </a>
   </h4>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    The gyroscope measures the angular velocity $\omega^{b}_{ib} $ at each time instance $t$, but its measurements are corrupted by a slowly time-varying bias $\delta_{\omega,t}$, and noise $e_{\omega,t}$:
$$
\begin{align}
y_{\omega,t} = \omega^{b}_{ib,t} + \delta_{\omega,t}^b + e_{\omega,t}^b
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    where $e_{\omega,t}^b \sim \mathcal{N}(0, \Sigma_{\omega})$. If the gyroscope is properly calibrated, we can think that measurements in three gyroscope axes are independent.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    The gyroscope bias $\delta_{\omega,t}^b$ is slowly time-varying:
$$
\begin{align}
\delta_{\omega,t+1}^b = \delta_{\omega,t}^b + e_{\delta_{\omega},t}^b
\end{align}
$$
where $e_{\delta_{\omega},t}^b \sim \mathcal{N}(0, \Sigma_{\delta_{\omega}})$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    From previous section we have $\omega_{ib}^b = R^{bn}(\omega_{ie}^n + \omega_{en}^n) + \omega_{nb}^b$. If we assume local navigation frame is stationary and neglect earth rotation, we can get:
$$
\begin{align}
\omega_{ib}^b = \omega_{nb}^b
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Then we can get
    <strong>
     gyroscope measurement model
    </strong>
    as:
$$
\begin{align}
y_{\omega,t} = \omega^{b}_{nb,t} + \delta_{\omega,t}^b + e_{\omega,t}^b
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h4 id="Accelerometer-measurement-models">
    Accelerometer measurement models
    <a class="anchor-link" href="#Accelerometer-measurement-models">
     ¶
    </a>
   </h4>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    The accelerometer measures the acceleration $a^{b}_{ii} $ at each time instance $t$, but its measurements are corrupted by a slowly time-varying bias $\delta_{a,t}$, and noise $e_{a,t}$:
$$
\begin{align}
y_{a,t} = a^{b}_{ii,t} + \delta_{a,t}^b + e_{a,t}^b
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    where $e_{a,t}^b \sim \mathcal{N}(0, \Sigma_{a})$. If the gyroscope is properly calibrated, we can think that measurements in three gyroscope axes are independent.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    The accelerometer bias $\delta_{a,t}^b$ is slowly time-varying:
$$
\begin{align}
\delta_{a,t+1}^b = \delta_{a,t}^b + e_{\delta_{a},t}^b
\end{align}
$$
where $e_{\delta_{a},t}^b \sim \mathcal{N}(0, \Sigma_{\delta_{a}})$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    As we discussed in the previous section that we have $a_{ii}^b = R^{bn}(a_{ii}^n - g^n)$, then
$$
\begin{align}
y_{a,t} = a^{b}_{ii,t} + \delta_{a,t}^b + e_{a,t}^b
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    If we neglect Centrifugal acceleration and Coriolis acceleration, we have $a_{ii}^n = a_{nn}^n$, the we can get
    <strong>
     accelerometer measurement model
    </strong>
    as:
$$
\begin{align}
y_{a,t} = R^{bn}(a_{nn}^n - g^n) + \delta_{a,t}^b + e_{a,t}^b
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h2 id="State-and-Dynamics">
    State and Dynamics
    <a class="anchor-link" href="#State-and-Dynamics">
     ¶
    </a>
   </h2>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Recall that we have two measurement models: 
$$
\begin{align}
y_{\omega,t} &amp;= \omega^{b}_{nb,t} + \delta_{\omega,t}^b + e_{\omega,t}^b \\
y_{a,t} &amp;= (q^{nb})^{-1} \odot (a_{nn}^n - g^n) + \delta_{a,t}^b + e_{a,t}^b
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Constant-Acceleration-Model">
    Constant Acceleration Model
    <a class="anchor-link" href="#Constant-Acceleration-Model">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    We can have a state vector as $x_t = (p_t^n, v_{n,t}^n, a_{nn,t}^n, \delta_{a,t}^b, q^{nb}_t, \omega^b_{nb, t}, \delta_{\omega,t}^b )$.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Assume that acceleration is constant and angular velocity is constant, we can get:
$$
\begin{align}
p_{t+1}^n   &amp;= p_t^n + T v_{n,t}^n + \frac{T^2}{2}a_{nn,t}^n \\
v_{n,t+1}^n &amp;= v_{n,t}^n + T a_{nn,t}^n \\
a_{nn,t+1}^n &amp;= a_{nn,t} + e_{a,t} \\
\delta_{a,t+1}^b &amp;= \delta_{a,t}^b + e_{\delta_{a},t}^b \\
q^{nb}_{t+1} &amp;= q^{nb}_t  \odot Exp_q(\frac{T}{2}\omega^b_{nb, t}) = R^{nb}_t Exp_R(T\omega^b_{nb, t})\\
\omega^b_{nb, t+1} &amp;= \omega^b_{nb, t} + e_{\omega,t} \\
\delta_{\omega,t+1}^b &amp;= \delta_{\omega,t}^b + e_{\delta_{\omega},t}^b
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    where $e_{a,t} \sim \mathcal{N}(0, \Sigma_{a})$, $e_{\omega,t} \sim \mathcal{N}(0, \Sigma_{\omega})$. $Exp()$ is an exponential operation as:
$$
\begin{align}
Exp_q(\eta) &amp;= (cos(\|\eta\|), \frac{\eta}{\|\eta\|}sin(\|\eta\|)))^T \\
Exp_R(\eta) &amp;= \mathcal{I}_3 + sin(\|\eta\|)[\frac{\eta}{\|\eta\|}]_{\times} + (1-cos(\|\eta\|)[\frac{\eta}{\|\eta\|}]_{\times}^2 
\end{align}
$$
    <strong>
     Note
    </strong>
    for an angle axis vector described as $(\alpha, \textbf{n})$, it is equal to $Exp_q(\frac{\alpha}{2}\textbf{n})$ and $Exp_R(\alpha\textbf{n})$.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Inertial-Measurements-Driven-Model">
    Inertial Measurements Driven Model
    <a class="anchor-link" href="#Inertial-Measurements-Driven-Model">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Instead of modeling $a_{nn,t}^n$ and $\omega^b_{nb, t}$ in the state vector, we could use IMU's measurements $y_{\omega,t}$ and $y_{a,t}$ to update the state. Hence, the state vector will be $(p_t^n, v_{n,t}^n, \delta_{a,t}^b, q^{nb}_t,  \delta_{\omega,t}^b )$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   $$
\begin{align}
p_{t+1}^n   &amp;= p_t^n + T v_{n,t}^n + \frac{T^2}{2}(q_t^{nb}(y_{a,t}-\delta_{a,t}^b-e_{a,t}^b)+g^n) \\
v_{n,t+1}^n &amp;= v_{n,t}^n + T (q_t^{nb}(y_{a,t}-\delta_{a,t}^b-e_{a,t}^b)+g^n) \\
\delta_{a,t+1}^b &amp;= \delta_{a,t}^b + e_{\delta_{a},t}^b \\
q^{nb}_{t+1} &amp;= q^{nb}_t  \odot Exp_q(\frac{T}{2}(y_{\omega, t} - \delta_{\omega,t}^b - e_{\omega,t}^b))\\
\delta_{\omega,t+1}^b &amp;= \delta_{\omega,t}^b + e_{\delta_{\omega},t}^b
\end{align}
$$
   <p>
    Note:
   </p>
   <ul>
    <li>
     $(q_t^{nb}(y_{a,t}-\delta_{a,t}^b-e_{a,t}^b)+g^n)$ could be simplified as $(q_t^{nb}(y_{a,t}-\delta_{a,t}^b)-e_{a,t}^b+g^n)$ if we consider $e_{a,t}$ have same noise for three axes as $\sim \mathcal{N}(0, \sigma_a^2\mathcal{I}_3)$.
    </li>
    <li>
     This numeric integration of the velocity and position assumes a constant orientation $q^{nb}_t$ for the time of integration between two measurements.
    </li>
   </ul>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h2 id="State-Estimation">
    State Estimation
    <a class="anchor-link" href="#State-Estimation">
     ¶
    </a>
   </h2>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Factor-Graph-based-Optimization">
    Factor Graph based Optimization
    <a class="anchor-link" href="#Factor-Graph-based-Optimization">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Firstly we will define the cost function to minimize along with the variables we want to optimize over. For position and orientation estimation of INS, if we use state vector as $(p_t^n, v_{n,t}^n, \delta_{a,t}^b, q^{nb}_t,  \delta_{\omega,t}^b )$, we can define the optimization problem as:
   </p>
   $$
\begin{align}
\hat{x}_{0:N} = \underset{x_{0:N}}{\operatorname{argmin}}&amp; 
\|e_{p,0}\|_{\Sigma^{-1}_{p^n_0}} 
+ \|e_{v,0}\|_{\Sigma^{-1}_{v^n_0}}
+ \|e_{q,0}\|_{\Sigma^{-1}_{q^{nb}_0}} \\
+&amp;\ \|e_{p,a,t}\|_{\Sigma^{-1}_{e_a}}
+ \|e_{v,a,t}\|_{\Sigma^{-1}_{e_a}}
+ \|e_{\omega,t}\|_{\Sigma^{-1}_{e_{\omega}}} \\
+&amp;\ \|e_{\delta_{\omega},t}\|_{\Sigma^{-1}_{\delta_{\omega}}}
+ \|e_{\delta_{a},t}\|_{\Sigma^{-1}_{\delta_{a}}} \\
+&amp;\ \|e_{m,t}\|_{\Sigma^{-1}_{e_m}}
\end{align}
$$
   <p>
    <strong>
     Note:
    </strong>
    we could optimize over state deviation, e.g. orientation deviation $\eta^{nb}$ instead of orientation $q^{nb}$.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Prior errors:
$$
\begin{align}
e_{p,0} &amp;= p^n_0 - y_{p,0} \\
e_{v,0} &amp;= v^n_0 - y_{v,0} \\
e_{q,0} &amp;= Log(q^{nb}_0 \odot y_{q, 0})
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    IMU dynamics errors:
$$
\begin{align}
e_{p,a,t} &amp;= \frac{2}{T^2}(p^n_{t+1} - p^n_{t} - T v^n_{n,t}) - g^n - q^{bn} \odot(y_{a,t}-\delta_{a,t}^b) \\
e_{v,a,t} &amp;= \frac{1}{T}(v^n_{t+1}-v^n_{t}) - g^n - q^{bn} \odot(y_{a,t}-\delta_{a,t}^b)  \\
e_{\omega,t} &amp;= \frac{2}{T}Log(q_t^{bn} \odot q_{t+1}^{nb}) - y_{\omega,t} + \delta_{\omega,t}
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Bias errors:
$$
\begin{align}
e_{\delta_{\omega},t} &amp;= \delta_{a,t+1}^b - \delta_{a,t}^b\\
e_{\delta_{a},t} &amp;= \delta_{\omega,t+1}^b - \delta_{\omega,t}^b
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Measurement errors:
   </p>
   <ul>
    <li>
     Position measurements
    </li>
   </ul>
   $$
\begin{align}
e_{m,t} &amp;= p^n_t - y_{p,t}
\end{align}
$$
   <ul>
    <li>
     Velocity measurements from wheel-encoder
    </li>
   </ul>
   $$
\begin{align}
e_{m,t} &amp;= R^{vb}R^{bn}v^n_{n,t} - y_{v,t}
\end{align}
$$
   <ul>
    <li>
     Zero angular velocity
$$
\begin{align}
e_{m,t} &amp;= Log(q_t^{bn} \odot q_{t+1}^{nb})
\end{align}
$$
    </li>
    <li>
     Zero linear velocity
$$
\begin{align}
e_{m,t} &amp;= v_t^n
\end{align}
$$
    </li>
    <li>
     Zero acceleration 
$$
\begin{align}
e_{m,t} &amp;= v_{t+1}^n - v_t^n
\end{align}
$$
    </li>
   </ul>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    I think a challenge to use IMU measurements driven model is that additional measurements might arrive at different freuqency than IMU measurements. We could interpolate the measurements for batch optimization since we have complete information for the whole time. This assumes that we have a state node in our factor graph when every IMU measurement comes in. This will leads to fast growth number of variables in the optimization.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h4 id="IMU-Noise-Model">
    IMU Noise Model
    <a class="anchor-link" href="#IMU-Noise-Model">
     ¶
    </a>
   </h4>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <ul>
    <li>
     <strong>
      Noise Density (ND)
     </strong>
     : It provides the noise divided by the square root of the sampling rate. The noise density for a gyroscope can be represented as $(^{\circ}/s)/\sqrt{Hz}$ or $(^{\circ}/hr)/\sqrt{Hz}$.By multiplying the noise density (ND) by the square root of the sampling rate (SR), the noise standard deviation $\sigma$ at that rate can be recovered $\sigma = ND * \sqrt{SR}$. When ND is specified as
     <strong>
      Power Spectral Density (PSD)
     </strong>
     , it is essentially $PSD = (ND)^2$.
    </li>
   </ul>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <ul>
    <li>
     <strong>
      Random Walk (RW)
     </strong>
     : The specification for random walk is typically given in units of $^{\circ}/\sqrt{s}$ for gyroscopes, and $(m/s)/\sqrt{s}$ for accelerometers. By multiplying the random walk by the square root of time, the standard deviation of the drift due to noise can be recovered $\sigma = \text{RW}\sqrt{t}$. For unit conversion, we can use $60\sqrt{s} = \sqrt{hr}$, $ 1 \text{milli-g} \approx 0.01 m/s^2$.
    </li>
   </ul>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <ul>
    <li>
     <strong>
      Bias
     </strong>
     : The bias is a constant offset of the output value from the input value. The in-run bias stability, or often called the bias instability, is a measure of how the bias will drift during operation over time at a constant temperature. This parameter also represents the best possible accuracy with which a sensor's bias can be estimated. Due to this, in-run bias stability is generally the most critical specification as it gives a floor to how accurate a bias can be measured.
    </li>
   </ul>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <ul>
    <li>
     <strong>
      Scale Factor
     </strong>
     : Scale factor is a multiplier on a signal that is comprised of a ratio of the output to the input over the measurement range. This factor typically varies over temperature and must be calibrated for over the operational temperature range.
    </li>
   </ul>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <ul>
    <li>
     <p>
      Summaries:
     </p>
     <ul>
      <li>
       $\sigma_a$ and $\sigma_{\omega}$ can be obtained by $\sigma_{discrete} = ND * \sqrt{SR} = RW * \sqrt{SR}$
      </li>
      <li>
       Based on Kalibr, $\sigma_{\delta_a}$ and $\sigma_{\delta_{\omega}}$ can be obtained by $\sigma_{discrete} = \sigma / \sqrt{SR}$
      </li>
      <li>
       Based on Kalibr, we can get continuous
       <a href="https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model#from-the-allan-standard-deviation-ad">
        noise values
       </a>
       based on Allan Variance plot.
      </li>
     </ul>
    </li>
   </ul>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Reference:
   </p>
   <ul>
    <li>
     <a href="https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model">
      https://github.com/ethz-asl/kalibr/wiki/IMU-Noise-Model
     </a>
    </li>
    <li>
     <a href="https://github.com/rpng/kalibr_allan">
      https://github.com/rpng/kalibr_allan
     </a>
    </li>
    <li>
     <a href="https://www.mathworks.com/help/fusion/ug/inertial-sensor-noise-analysis-using-allan-variance.html">
      https://www.mathworks.com/help/fusion/ug/inertial-sensor-noise-analysis-using-allan-variance.html
     </a>
    </li>
    <li>
     <a href="https://www.vectornav.com/resources/inertial-navigation-primer/specifications--and--error-budgets/specs-imuspecs">
      https://www.vectornav.com/resources/inertial-navigation-primer/specifications--and--error-budgets/specs-imuspecs
     </a>
    </li>
    <li>
     <a href="https://www.vectornav.com/resources/inertial-navigation-primer/examples/noise">
      https://www.vectornav.com/resources/inertial-navigation-primer/examples/noise
     </a>
    </li>
    <li>
     <a href="https://telesens.co/wp-content/uploads/2017/05/AllanVariance5087-1.pdf">
      https://telesens.co/wp-content/uploads/2017/05/AllanVariance5087-1.pdf
     </a>
    </li>
    <li>
     <a href="https://mwrona.com/posts/gyro-noise-analysis/">
      https://mwrona.com/posts/gyro-noise-analysis/
     </a>
    </li>
    <li>
     <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-696.pdf">
      https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-696.pdf
     </a>
    </li>
   </ul>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [ ]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># Allan Plot Sample Code</span>
<span class="c1"># From blog post: https://mwrona.com/posts/gyro-noise-analysis/</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">AllanDeviation</span><span class="p">(</span><span class="n">dataArr</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">maxNumM</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="sd">"""Compute the Allan deviation (sigma) of time-series data.</span>

<span class="sd">    Algorithm obtained from Mathworks:</span>
<span class="sd">    https://www.mathworks.com/help/fusion/ug/inertial-sensor-noise-analysis-using-allan-variance.html</span>

<span class="sd">    Args</span>
<span class="sd">    ----</span>
<span class="sd">        dataArr (numpy.ndarray): 1D data array</span>
<span class="sd">        fs (int, float): Data sample frequency in Hz</span>
<span class="sd">        maxNumM (int): Number of output points</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        (taus, allanDev): Tuple of results</span>
<span class="sd">        taus (numpy.ndarray): Array of tau values</span>
<span class="sd">        allanDev (numpy.ndarray): Array of computed Allan deviations</span>
<span class="sd">    """</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">fs</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataArr</span><span class="p">)</span>
    <span class="n">Mmax</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">Mmax</span><span class="p">),</span> <span class="n">num</span><span class="o">=</span><span class="n">maxNumM</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>  <span class="c1"># Round up to integer</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>  <span class="c1"># Remove duplicates</span>
    <span class="n">taus</span> <span class="o">=</span> <span class="n">M</span> <span class="o">*</span> <span class="n">ts</span>  <span class="c1"># Compute 'cluster durations' tau</span>

    <span class="c1"># Compute Allan variance</span>
    <span class="n">allanVar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">twoMi</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mi</span><span class="p">)</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mi</span><span class="p">)</span>
        <span class="n">allanVar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="p">(</span><span class="n">dataArr</span><span class="p">[</span><span class="n">twoMi</span><span class="p">:</span><span class="n">N</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">dataArr</span><span class="p">[</span><span class="n">mi</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="n">mi</span><span class="p">])</span> <span class="o">+</span> <span class="n">dataArr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="n">twoMi</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="p">)</span>
    
    <span class="n">allanVar</span> <span class="o">/=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">taus</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">M</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">taus</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">allanVar</span><span class="p">))</span>  <span class="c1"># Return deviation (dev = sqrt(var))</span>

<span class="c1"># Config. params</span>
<span class="n">DATA_FILE</span> <span class="o">=</span> <span class="s1">'gyro-data.csv'</span>  <span class="c1"># CSV data file "gx,gy,gz"</span>
<span class="n">fs</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># Sample rate [Hz]</span>

<span class="c1"># Load CSV into np array</span>
<span class="n">dataArr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">DATA_FILE</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">','</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">fs</span>

<span class="c1"># Separate into arrays</span>
<span class="n">gx</span> <span class="o">=</span> <span class="n">dataArr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>  <span class="c1"># [deg/s]</span>
<span class="n">gy</span> <span class="o">=</span> <span class="n">dataArr</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">gz</span> <span class="o">=</span> <span class="n">dataArr</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

<span class="c1"># Calculate gyro angles</span>
<span class="n">thetax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">gx</span><span class="p">)</span> <span class="o">*</span> <span class="n">ts</span>  <span class="c1"># [deg]</span>
<span class="n">thetay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">gy</span><span class="p">)</span> <span class="o">*</span> <span class="n">ts</span>
<span class="n">thetaz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">gz</span><span class="p">)</span> <span class="o">*</span> <span class="n">ts</span>

<span class="c1"># Compute Allan deviations</span>
<span class="p">(</span><span class="n">taux</span><span class="p">,</span> <span class="n">adx</span><span class="p">)</span> <span class="o">=</span> <span class="n">AllanDeviation</span><span class="p">(</span><span class="n">thetax</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">maxNumM</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="p">(</span><span class="n">tauy</span><span class="p">,</span> <span class="n">ady</span><span class="p">)</span> <span class="o">=</span> <span class="n">AllanDeviation</span><span class="p">(</span><span class="n">thetay</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">maxNumM</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="p">(</span><span class="n">tauz</span><span class="p">,</span> <span class="n">adz</span><span class="p">)</span> <span class="o">=</span> <span class="n">AllanDeviation</span><span class="p">(</span><span class="n">thetaz</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">maxNumM</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

<span class="c1"># Plot data on log-scale</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Gyro Allan Deviations'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">taux</span><span class="p">,</span> <span class="n">adx</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">'gx'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tauy</span><span class="p">,</span> <span class="n">ady</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">'gy'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tauz</span><span class="p">,</span> <span class="n">adz</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">'gz'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">'$\tau$ [sec]'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'Deviation [deg/sec]'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">"both"</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">"-"</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">'0.65'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xscale</span><span class="p">(</span><span class="s1">'log'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s1">'log'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h4 id="IMU-Preintegration">
    IMU Preintegration
    <a class="anchor-link" href="#IMU-Preintegration">
     ¶
    </a>
   </h4>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    In short, we want to generate IMU factors between keyframes, which can be pre-computed just based on IMU measurements and time interval between keyframes so that they are not required to be recomputed after updating linearization points of state variables. This requires
    <strong>
     IMU and keyframe timestamps are synchronized
    </strong>
    .
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h5 id="1)-Preintegrated-IMU-Measurements-with-assumption-that-bias-is-constant.">
    <strong>
     1) Preintegrated IMU Measurements with assumption that bias is constant
    </strong>
    .
    <a class="anchor-link" href="#1)-Preintegrated-IMU-Measurements-with-assumption-that-bias-is-constant.">
     ¶
    </a>
   </h5>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Suppose we have state $x_i$ at timestamp $t_i$, then
$$
\begin{align}
\Delta R_{ij} &amp;= R_i^T R_{j} \\ 
&amp;= \prod_{k=i}^{j-1} Exp_{R}(T(y_{\omega, k} - \delta_{\omega,k}^b - e_{\omega,k}^b))\\
\Delta v_{ij} &amp;= R_i^T(v_j-v_i-(j-i)Tg) \\ 
&amp;= \sum_{k=i}^{j-1}[T\Delta R_{ik}(y_{a,k}-\delta_{a,k}^b-e_{a,k}^b)]\\
\Delta p_{ij} &amp;= R_i^T(p_j - p_i - (j-i)Tv_i -\frac{1}{2}(j-i)^2T^2g) \\
&amp;= \sum_{k=i}^{j-1}[T\Delta v_{ik} + \frac{1}{2}\Delta R_{ik}(j-i)^2T^2(y_{a,k}-\delta_{a,k}^b-e_{a,k}^b)]
\end{align}
$$
The equation above clearly describe the relations between state variables and measurements. However, in order to be able to fit into a MAP estimation simply, we need it be in form as $y = f(x) + e$.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Given $Exp(\phi + \delta\phi) \approx\ Exp(\phi)Exp(J_r(\phi)\delta\phi)$ and assume $e_{\omega,k}^b$ is very small, we can have following equations with $\phi_k = T(y_{\omega, k} - \delta_{\omega,k}^b)$ and $\delta \phi = T(-e_{\omega,k}^b)$
$$
\begin{align}
\Delta R_{ij} &amp;= \prod_{k=i}^{j-1} Exp_{R}(T(y_{\omega, k} - \delta_{\omega,k}^b - e_{\omega,k}^b)) \\
&amp;= \prod_{k=i}^{j-1}Exp_{R}(T(y_{\omega, k} - \delta_{\omega,k}^b))Exp_{R}(J_{r_k}T(-e_{\omega,k}^b))
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Then given $Exp(\phi) R = R Exp(R^T \phi)$, we can have following equations with $\Delta R_k = Exp_{R}(T(y_{\omega, k} - \delta_{\omega,k}^b))$
$$
\begin{align}
\Delta R_{ij} &amp;=  \prod_{k=i}^{j-1}Exp_{R}(T(y_{\omega, k} - \delta_{\omega,k}^b))Exp_{R}(J_{r_k}T(-e_{\omega,k}^b)) \\
&amp;= \Delta R_i Exp_{R}(J_{r_i}T(-e_{\omega,i}^b)) \Delta R_{i+1} Exp_{R}(J_{r_{i+1}}T(-e_{\omega,{i+1}}^b))\Delta R_{i+2} \cdots \\
&amp;= \Delta R_i \{Exp_{R}(J_{r_i}T(-e_{\omega,i}^b)) [\Delta R_{i+1}\Delta R_{i+2}]\} \{Exp_{R}(\Delta R_{i+2}^T J_{r_{i+1}}T(-e_{\omega,{i+1}}^b))\} \cdots \\
&amp;= \Delta R_i\Delta R_{i+1}\Delta R_{i+2} \{Exp_{R}((\Delta R_{i+1}\Delta R_{i+2})^TJ_{r_i}T(-e_{\omega,i}^b))\} \{Exp_{R}(\Delta R_{i+2}^T J_{r_{i+1}}T(-e_{\omega,{i+1}}^b))\} \cdots \\
&amp;= \Delta {\tilde{R}_{ij}}\prod_{k=i}^{j-1}[Exp_R(\Delta {\tilde{R}_{k+1,j}^T}J_{r_k}T(-e_{\omega,k}^b))] \\
&amp;= \Delta {\tilde{R}_{ij}}Exp_R(-\delta \phi_{ij})
\end{align}
$$
where $\Delta {\tilde{R}_{ij}} = \prod_{k=i}^{j-1}Exp_{R}(T(y_{\omega, k} - \delta_{\omega,k}^b))$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Similarly, we can get:
$$
\begin{align}
\Delta v_{ij} &amp;= \sum_{k=i}^{j-1}[T\Delta R_{ik}(y_{a,k}-\delta_{a,k}^b-e_{a,k}^b)]\\
&amp;= \sum_{k=i}^{j-1}[T\Delta {\tilde{R}_{ik}}Exp_R(-\delta \phi_{ik})(y_{a,k}-\delta_{a,k}^b-e_{a,k}^b)]
\end{align}
$$
With first-order approximation $Exp_R(\delta \phi) = \mathcal{I} + [\delta \phi]_{\times}$, we can get:
$$
\begin{align}
\Delta v_{ij} &amp;= \sum_{k=i}^{j-1}[T\Delta {\tilde{R}_{ik}}Exp_R(-\delta \phi_{ik})(y_{a,k}-\delta_{a,k}^b-e_{a,k}^b)]\\
&amp;= \sum_{k=i}^{j-1}[T\Delta {\tilde{R}_{ik}}(\mathcal{I}-[\delta \phi_{ik}]_\times)(y_{a,k}-\delta_{a,k}^b-e_{a,k}^b)] \\
&amp;= \sum_{k=i}^{j-1}[T\Delta {\tilde{R}_{ik}}(\mathcal{I}-[\delta \phi_{ik}]_\times)(y_{a,k}-\delta_{a,k}^b) - T\Delta {\tilde{R}_{ik}}e_{a,k}^b] \\
\end{align}
$$
Note that we omit a higher order noise as $T\Delta {\tilde{R}_{ik}}\delta \phi_{ik}e_{a,k}^b$ in the third line of the equations.
   </p>
   <p>
    Then with $[a]_\times b = -b_\times a$
$$
\begin{align}
\Delta v_{ij} &amp;= \sum_{k=i}^{j-1}[T\Delta {\tilde{R}_{ik}}(\mathcal{I}-[\delta \phi_{ik}]_\times)(y_{a,k}-\delta_{a,k}^b) - T\Delta {\tilde{R}_{ik}}e_{a,k}^b] \\
&amp;= \Delta{\tilde{v_{ij}}} - \sum_{k=i}^{j-1}[T\Delta {\tilde{R}_{ik}}(e_{a,k}^b + [\delta \phi_{ik}]_\times(y_{a,k}-\delta_{a,k}^b))] \\
&amp;= \Delta{\tilde{v_{ij}}} - \sum_{k=i}^{j-1}[T\Delta {\tilde{R}_{ik}}(e_{a,k}^b - [y_{a,k}-\delta_{a,k}^b]_\times(\delta \phi_{ik}))]\\
&amp;= \Delta{\tilde{v_{ij}}} - \delta v_{ij}
\end{align}
$$
where $\Delta{\tilde{v_{ij}}} = \sum_{k=i}^{j-1}[T\Delta {\tilde{R}_{ik}}(y_{a,k}-\delta_{a,k}^b)]$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   $$
\begin{align}
\Delta p_{ij} &amp;= \sum_{k=i}^{j-1}[T\Delta v_{ik} + \frac{1}{2}\Delta R_{ik}(j-i)^2T^2(y_{a,k}-\delta_{a,k}^b-e_{a,k}^b)] \\
&amp;= \Delta{\tilde{p}_{ij}} - \sum_{k=i}^{j-1}[T\delta v_{ik} + \frac{1}{2}T^2\Delta {\tilde{R}_{ik}}(e_{a,k}^b -[y_{a,k}-\delta_{a,k}^b]_\times(\delta \phi_{ik}))] \\
&amp;= \Delta{\tilde{p}_{ij}} - \delta p_{ij}
\end{align}
$$
   <p>
    where $\Delta{\tilde{p}_{ij}} = \sum_{k=i}^{j-1}[T\Delta{\tilde{v_{ij}}}-\frac{1}{2}T^2 {\tilde{R}_{ik}}(y_{a,k}-\delta_{a,k}^b)]$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h5 id="2)-Noise-propagation">
    2)
    <strong>
     Noise propagation
    </strong>
    <a class="anchor-link" href="#2)-Noise-propagation">
     ¶
    </a>
   </h5>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Now we get noise term $\delta p_{ij}, \delta v_{ij}, \delta \phi_{ij}$, which also follows zero mean Gaussian distribution. How can we get
    <strong>
     find correct covariance
    </strong>
    for them?
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   $$
\begin{align}
Exp_R(-\delta \phi_{ij}) &amp;= \prod_{k=i}^{j-1}[Exp_R(\Delta {\tilde{R}_{k+1,j}^T}J_{r_k}T(-e_{\omega,k}^b))] \\
\delta \phi_{ij} &amp;= -Log(\prod_{k=i}^{j-1}[Exp_R(\Delta {\tilde{R}_{k+1,j}^T}J_{r_k}T(-e_{\omega,k}^b))])
\end{align}
$$
   <p>
    Given $Log(Exp(\phi)Exp(\delta\phi)) \approx\ \phi + J_r^{-1}(\phi)\delta\phi$, we have $Log(Exp(\delta \phi_1)Exp(\delta\phi_2)) \approx\ \delta\phi_1 + \delta\phi_2$. Then we have:
$$
\begin{align}
\delta \phi_{ij} &amp;= -Log(\prod_{k=i}^{j-1}[Exp_R(\Delta {\tilde{R}_{k+1,j}^T}J_{r_k}T(-e_{\omega,k}^b))])\\
&amp; \approx \sum_{k=i}^{j-1} \Delta \tilde{R}_{k+1,j}^T J_{r_k}Te_{\omega,k}^b
\end{align}
$$
Then we can use linear propagation as 
$$
\begin{align}
\Sigma_{\delta \phi_{ij}} &amp; \approx  \sum_{k=i}^{j-1} (\Delta \tilde{R}_{k+1,j}^T J_{r_k}T)\Sigma_{e_{\omega,k}^b}(\Delta \tilde{R}_{k+1,j}^T J_{r_k}T)^T
\end{align}
$$
Where $\sigma_{\omega}$ can be obtained by $\sigma_{discrete} = ND * \sqrt{SR} = RW * \sqrt{SR}$.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Similarly, noise propagation for velocity and position are also just linear propagation.
$$
\begin{align}
\delta v_{ij} &amp;= \sum_{k=i}^{j-1}[T\Delta {\tilde{R}_{ik}}e_{a,k}^b - T\Delta {\tilde{R}_{ik}}[y_{a,k}-\delta_{a,k}^b]_\times(\delta \phi_{ik})]
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   $$
\begin{align}
\delta p_{ij} &amp;=  \sum_{k=i}^{j-1}[T\delta v_{ik} + \frac{1}{2}T^2\Delta {\tilde{R}_{ik}}e_{a,k}^b -\frac{1}{2}T^2\Delta {\tilde{R}_{ik}}[y_{a,k}-\delta_{a,k}^b]_\times(\delta \phi_{ik})]
\end{align}
$$
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h5 id="3)-Incorporating-non-constant-bias">
    3)
    <strong>
     Incorporating non-constant bias
    </strong>
    <a class="anchor-link" href="#3)-Incorporating-non-constant-bias">
     ¶
    </a>
   </h5>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    From the previous section, we know all pre-integrated measurements depend on bias estimation $\delta_{a,i}$ and $\delta_{\omega,i}$, where we assume constant bias between frames, aka $\delta_{i} == \delta_{j}$. So this means that if the bias estimation changes, we need to re-calculate all measurements which is exactly what we want to avoid.
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    The solution is to use Taylor expansion $f(x) \approx f(a) + J_x|_{x=a}(x-a)$. 
$$
\begin{align}
\Delta {\tilde{R}_{ij}} &amp;= \prod_{k=i}^{j-1}Exp_{R}(T(y_{\omega, k} - \delta_{\omega,k}^b)) \\
&amp;= f_{R_{ij}}(\delta_{\omega,i}^b) \\
&amp;= f_{R_{ij}}(\bar{\delta}_{\omega,i}^b + \Delta \delta_{\omega,i}^b) \\
&amp;\approx f_{R_{ij}}(\bar{\delta}_{\omega,i}^b) + J^{R_{ij}}_{\delta_{\omega,i}}|_{\delta_{\omega,i} = \bar{\delta}_{\omega,i}^b} \Delta \delta_{\omega,i}^b \\
\end{align}
$$
   </p>
   <p>
    Calculating the Jacobian matrix $J^{R_{ij}}_{\delta_{\omega,i}}|_{\delta_{\omega,i}= \bar{\delta}_{\omega,i}^b}$ is not trivial. Next, we will figure it out.
   </p>
   $$
\begin{align}
\Delta {\tilde{R}_{ij}} &amp;= \prod_{k=i}^{j-1}Exp_{R}(T(y_{\omega, k} - \delta_{\omega,k}^b)) \\
&amp;= \prod_{k=i}^{j-1}Exp_{R}(T(y_{\omega, k} - \bar{\delta}_{\omega,i}^b) - T\Delta \delta_{\omega,i}^b)
\end{align}
$$
   <p>
    Based on $Exp(\phi + \delta\phi) \approx Exp(\phi)Exp(J_r(\phi)\delta\phi)$, $\phi = T(y_{\omega, k} - \bar{\delta}_{\omega,i}^b)$ and  $\delta \phi = - T\Delta \delta_{\omega,i}^b$,
$$
\begin{align}
\Delta {\tilde{R}_{ij}} &amp;= \prod_{k=i}^{j-1}Exp_{R}(T(y_{\omega, k} - \bar{\delta}_{\omega,i}^b) - T\Delta \delta_{\omega,i}^b) \\
&amp;= \prod_{k=i}^{j-1}Exp_{R}(T(y_{\omega, k} - \bar{\delta}_{\omega,i}^b)\prod_{k=i}^{j-1}Exp_{R}(-J_r^k \Delta \delta_{\omega,i}^b)
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Based on similar derivation for $\Delta R_{ij}$, we can get 
$$
\begin{align}
\Delta {\tilde{R}_{ij}} &amp;= \prod_{k=i}^{j-1}Exp_{R}(T(y_{\omega, k} - \bar{\delta}_{\omega,i}^b)\prod_{k=i}^{j-1}Exp_{R}(-J_{r_k} \Delta \delta_{\omega,i}^b)\\
&amp;= f_{R_{ij}}(\bar{\delta}_{\omega,i}^b)\prod_{k=i}^{j-1}[Exp_R(f_{R_{k+1,j}}(\bar{\delta}_{\omega,i}^b)^T J_{r_k}T(-\Delta \delta_{\omega,i}^b))] \\
\end{align}
$$
Then based on $Exp(\phi + J_r^{-1}(\phi)\delta\phi) \approx Exp(\phi)Exp(J_r(\phi)J_r^{-1}(\phi)\delta\phi)$ and assume $f_{R_{_{k+1,j}}}(\bar{\delta}_{\omega,i}^b)^T J_{r_k}T(-\Delta \delta_{\omega,i}^b)$ is also suffient small, we can have:
$$
\begin{align}
\Delta {\tilde{R}_{ij}} &amp;= f_{R_{ij}}(\bar{\delta}_{\omega,i}^b)\prod_{k=i}^{j-1}[Exp_R(f_{R_{k+1,j}}(\bar{\delta}_{\omega,i}^b)^T J_{r_k}T(-\Delta \delta_{\omega,i}^b))] \\
 &amp;= f_{R_{ij}}(\bar{\delta}_{\omega,i}^b)Exp_R(\sum_{k=i}^{j-1}[f_{R_{k+1,j}}(\bar{\delta}_{\omega,i}^b)^T J_{r_k}T(-\Delta \delta_{\omega,i}^b)]) \\
 &amp;= f_{R_{ij}}(\bar{\delta}_{\omega,i}^b)Exp_R(\mathcal{J}_{\delta_{\omega,i}^b}^{f_{R_{ij}}}\Delta \delta_{\omega,i}^b)
\end{align}
$$
where $\mathcal{J}_{\delta_{\omega,i}^b}^{f_{R_{ij}}} = -\sum_{k=i}^{j-1}[f_{R_{k+1,j}}(\bar{\delta}_{\omega,i}^b)^T J_{r_k}T]$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Similarly for speed residual, we can have:
$$
\begin{align}
\Delta{\tilde{v}_{ij}} &amp;= \sum_{k=i}^{j-1}[T\Delta {\tilde{R}_{ik}}(y_{a,k}-\delta_{a,k}^b)]\\
&amp;= f_{v_{ij}}(\delta_{a,i}^b, \delta_{\omega,i}^b) \\
&amp;= f_{v_{ij}}(\bar{\delta}_{a,i}^b+\Delta \delta_{a,i}^b, \bar{\delta}_{\omega,i}^b + \Delta \delta_{\omega,i}^b) \\
&amp;\approx f_{v_{ij}}(\bar{\delta}_{a,i}^b, \bar{\delta}_{\omega,i}^b) + J^v_{\delta_{a,i}}|_{\delta_{a,i}^b=\bar{\delta}_{a,i}^b} \Delta \delta_{a,i}^b + J^v_{\delta_{\omega,i}}|_{\delta_{\omega,i} = \bar{\delta}_{\omega,i}^b} \Delta \delta_{\omega,i}^b
\end{align}
$$
   </p>
   $$
\begin{align}
\Delta{\tilde{v}_{ij}} &amp;= \sum_{k=i}^{j-1}[T\Delta {\tilde{R}_{ik}}(y_{a,k}-\delta_{a,k}^b)]\\
&amp;= \sum_{k=i}^{j-1}[T f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)Exp_R(\mathcal{J}_{\delta_{\omega,i}^b}^{f_{R_{ik}}}\Delta \delta_{\omega,i}^b))(y_{a,k}-\bar{\delta}_{a,i}^b - \Delta \delta_{a,i}^b)] \\
&amp;\approx \sum_{k=i}^{j-1}[T f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)(\mathcal{I} + [\mathcal{J}_{\delta_{\omega,i}^b}^{f_{R_{ik}}}\Delta \delta_{\omega,i}^b)]_{\times})(y_{a,k}-\bar{\delta}_{a,i}^b - \Delta \delta_{a,i}^b)] \\
&amp;= f_{v_{ij}}(\bar{\delta}_{a,i}^b, \bar{\delta}_{\omega,i}^b) - \sum_{k=i}^{j-1}[T f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)\Delta \delta_{a,i}^b - T f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)[\mathcal{J}_{\delta_{\omega,i}^b}^{f_{R_{ik}}}\Delta \delta_{\omega,i}^b]_{\times}(y_{a,k}-\bar{\delta}_{a,i}^b)] + o(\text{high order term})\\
&amp;= f_{v_{ij}}(\bar{\delta}_{a,i}^b, \bar{\delta}_{\omega,i}^b) - \sum_{k=i}^{j-1}[T f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)\Delta \delta_{a,i}^b + T f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)[y_{a,k}-\bar{\delta}_{a,i}^b]_{\times}\mathcal{J}_{\delta_{\omega,i}^b}^{f_{R_{ik}}}\Delta \delta_{\omega,i}^b]\\
&amp;= f_{v_{ij}}(\bar{\delta}_{a,i}^b, \bar{\delta}_{\omega,i}^b) + \mathcal{J}_{\delta_{a,i}^b}^{f_{v_{ij}}}\Delta \delta_{a,i}^b + \mathcal{J}_{\delta_{\omega,,i}^b}^{f_{v_{ij}}}\Delta \delta_{\omega,i}^b
\end{align}
$$
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Similarly for position residual, we can have:
$$
\begin{align}
\Delta{\tilde{p}_{ij}} &amp;= \sum_{k=i}^{j-1}[T\Delta{\tilde{v_{ij}}}-\frac{1}{2}T^2 {\tilde{R}_{ik}}(y_{a,k}-\delta_{a,k}^b)] \\
&amp;= f_p(\delta_{a,i}^b, \delta_{\omega,i}^b) \\
&amp;= f_p(\bar{\delta}_{a,i}^b+\Delta \delta_{a,i}^b, \bar{\delta}_{\omega,i}^b + \Delta \delta_{\omega,i}^b) \\
&amp;\approx f_p(\bar{\delta}_{a,i}^b, \bar{\delta}_{\omega,i}^b) + J^p_{\delta_{a,i}}|_{\delta_{a,i}^b=\bar{\delta}_{a,i}^b} \Delta \delta_{a,i}^b + J^p_{\delta_{\omega,i}}|_{\delta_{\omega,i} = \bar{\delta}_{\omega,i}^b} \Delta \delta_{\omega,i}^b
\end{align}
$$
   </p>
   $$
\begin{align}
\Delta{\tilde{p}_{ij}} &amp;= \sum_{k=i}^{j-1}[T\Delta{\tilde{v_{ij}}}-\frac{1}{2}T^2 {\tilde{R}_{ik}}(y_{a,k}-\delta_{a,k}^b)] \\
&amp;= \sum_{k=i}^{j-1}[T f_{v_{ik}}(\bar{\delta}_{a,i}^b, \bar{\delta}_{\omega,i}^b) + T\mathcal{J}_{\delta_{a,i}^b}^{f_{v_{ik}}}\Delta \delta_{a,i}^b + T\mathcal{J}_{\delta_{\omega,,i}^b}^{f_{v_{ik}}}\Delta \delta_{\omega,i}^b -\frac{1}{2}T^2 f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)Exp_R(\mathcal{J}_{\delta_{\omega,i}^b}^{f_{R_{ik}}}\Delta \delta_{\omega,i}^b))(y_{a,k}-\bar{\delta}_{a,i}^b - \Delta \delta_{a,i}^b)] \\
&amp;\approx \sum_{k=i}^{j-1}[T f_{v_{ik}}(\bar{\delta}_{a,i}^b, \bar{\delta}_{\omega,i}^b) + T\mathcal{J}_{\delta_{a,i}^b}^{f_{v_{ik}}}\Delta \delta_{a,i}^b + T\mathcal{J}_{\delta_{\omega,,i}^b}^{f_{v_{ik}}}\Delta \delta_{\omega,i}^b -\frac{1}{2}T^2 f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)(\mathcal{I} + [\mathcal{J}_{\delta_{\omega,i}^b}^{f_{R_{ik}}}\Delta \delta_{\omega,i}^b)]_{\times})(y_{a,k}-\bar{\delta}_{a,i}^b - \Delta \delta_{a,i}^b)] \\
&amp;= f_p(\bar{\delta}_{a,i}^b, \bar{\delta}_{\omega,i}^b) + \sum_{k=i}^{j-1}[T\mathcal{J}_{\delta_{a,i}^b}^{f_{v_{ik}}}\Delta \delta_{a,i}^b + T\mathcal{J}_{\delta_{\omega,,i}^b}^{f_{v_{ik}}}\Delta \delta_{\omega,i}^b -\frac{1}{2}T^2 f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)\Delta \delta_{a,i}^b - \frac{1}{2}T^2 f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)[\mathcal{J}_{\delta_{\omega,i}^b}^{f_{R_{ik}}}\Delta \delta_{\omega,i}^b]_{\times}(y_{a,k}-\bar{\delta}_{a,i}^b)] + o(\text{high order term}) \\
&amp;= f_p(\bar{\delta}_{a,i}^b, \bar{\delta}_{\omega,i}^b) + \sum_{k=i}^{j-1}[T\mathcal{J}_{\delta_{a,i}^b}^{f_{v_{ik}}}\Delta \delta_{a,i}^b + T\mathcal{J}_{\delta_{\omega,,i}^b}^{f_{v_{ik}}}\Delta \delta_{\omega,i}^b -\frac{1}{2}T^2 f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)\Delta \delta_{a,i}^b - \frac{1}{2}T^2 f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)[y_{a,k}-\bar{\delta}_{a,i}^b]_{\times}\mathcal{J}_{\delta_{\omega,i}^b}^{f_{R_{ik}}}\Delta \delta_{\omega,i}^b] \\
&amp;= f_p(\bar{\delta}_{a,i}^b, \bar{\delta}_{\omega,i}^b) + \mathcal{J}_{\delta_{a,i}^b}^{f_{p_{ij}}}\Delta \delta_{a,i}^b + \mathcal{J}_{\delta_{\omega,,i}^b}^{f_{p_{ij}}}\Delta \delta_{\omega,i}^b
\end{align}
$$
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h5 id="4)-Summary">
    4)
    <strong>
     Summary
    </strong>
    <a class="anchor-link" href="#4)-Summary">
     ¶
    </a>
   </h5>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Base on the derivations in previous three sections, we can finally find the residual functions as:
$$
\begin{align}
r_{\Delta R_{ij}} &amp;= Log(\Delta {\tilde{R}_{ij}^T}R_i^TR_j) \\
&amp;= Log((f_{R_{ij}}(\bar{\delta}_{\omega,i}^b)Exp_R(\mathcal{J}_{\delta_{\omega,i}^b}^{f_{R_{ij}}}\Delta \delta_{\omega,i}^b))^TR_i^TR_j)
\end{align}
$$
where $f_{R_{ij}}(\delta_{\omega,i}^b) = \prod_{k=i}^{j-1}Exp_{R}(T(y_{\omega, k} - \delta_{\omega,i}^b))$ and $\mathcal{J}_{\delta_{\omega,i}^b}^{f_{R_{ij}}} = -\sum_{k=i}^{j-1}[f_{R_{k+1,j}}(\bar{\delta}_{\omega,i}^b)^T J_{r_k}T]$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   $$
\begin{align}
r_{\Delta v_{ij}} &amp;= R_i^T(v_j-v_i-(j-i)Tg) - \Delta{\tilde{v}_{ij}} \\
&amp;= R_i^T(v_j-v_i-(j-i)Tg) - f_{v_{ij}}(\bar{\delta}_{a,i}^b, \bar{\delta}_{\omega,i}^b) - \mathcal{J}_{\delta_{a,i}^b}^{f_{v_{ij}}}\Delta \delta_{a,i}^b - \mathcal{J}_{\delta_{\omega,i}^b}^{f_{v_{ij}}}\Delta \delta_{\omega,i}^b
\end{align}
$$
   <p>
    where $f_{v_{ij}}(\delta_{a,i}^b, \delta_{\omega,i}^b) = \sum_{k=i}^{j-1}[T\Delta {\tilde{R}_{ik}}(y_{a,k}-\delta_{a,k}^b)]$, $\mathcal{J}_{\delta_{a,i}^b}^{f_{v_{ij}}} = -\sum_{k=i}^{j-1}[T f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)]$ and $\mathcal{J}_{\delta_{\omega,,i}^b}^{f_{v_{ij}}} = -\sum_{k=i}^{j-1}[T f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)[y_{a,k}-\bar{\delta}_{a,i}^b]_{\times}\mathcal{J}_{\delta_{\omega,i}^b}^{f_{R_{ik}}}]$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   $$
\begin{align}
r_{\Delta p_{ij}} &amp;=  R_i^T(p_j - p_i - (j-i)Tv_i -\frac{1}{2}(j-i)^2T^2g) - \Delta{\tilde{p}_{ij}}\\
&amp;= R_i^T(p_j - p_i - (j-i)Tv_i -\frac{1}{2}(j-i)^2T^2g) - f_p(\bar{\delta}_{a,i}^b, \bar{\delta}_{\omega,i}^b) - \mathcal{J}_{\delta_{a,i}^b}^{f_{p_{ij}}}\Delta \delta_{a,i}^b - \mathcal{J}_{\delta_{\omega,,i}^b}^{f_{p_{ij}}}\Delta \delta_{\omega,i}^b
\end{align}
$$
   <p>
    where $f_p(\delta_{a,i}^b, \delta_{\omega,i}^b) = \sum_{k=i}^{j-1}[T\Delta{\tilde{v_{ij}}}-\frac{1}{2}T^2 {\tilde{R}_{ik}}(y_{a,k}-\delta_{a,k}^b)]$, $\mathcal{J}_{\delta_{a,i}^b}^{f_{p_{ij}}}=\sum_{k=i}^{j-1}[T\mathcal{J}_{\delta_{a,i}^b}^{f_{v_{ik}}}\ - \frac{1}{2}T^2 f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)]$ and $\mathcal{J}_{\delta_{\omega,,i}^b}^{f_{p_{ij}}}=\sum_{k=i}^{j-1}[T\mathcal{J}_{\delta_{\omega,,i}^b}^{f_{v_{ik}}} - \frac{1}{2}T^2 f_{R_{ik}}(\bar{\delta}_{\omega,i}^b)[y_{a,k}-\bar{\delta}_{a,i}^b]_{\times}\mathcal{J}_{\delta_{\omega,i}^b}^{f_{R_{ik}}}]$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    <strong>
     SO what values do we need to calculate between frame $i$ and $j$?
    </strong>
   </p>
   <ul>
    <li>
     $f_{R_{ik}}(\delta_{\omega,k}^b)$ and $\mathcal{J}_{\delta_{\omega,i}^b}^{f_{R_{ik}}}$
    </li>
    <li>
     $f_{v_{ik}}(\delta_{a,i}^b, \delta_{\omega,i}^b)$ and $\mathcal{J}_{\delta_{a,i}^b}^{f_{v_{ik}}}$ and $\mathcal{J}_{\delta_{\omega,i}^b}^{f_{v_{ik}}}$
    </li>
    <li>
     $f_{p}(\delta_{a,i}^b, \delta_{\omega,i}^b)$ and $\mathcal{J}_{\delta_{a,i}^b}^{f_{p_{ij}}}$ and $\mathcal{J}_{\delta_{\omega,,i}^b}^{f_{p_{ij}}}$
    </li>
   </ul>
   <p>
    <strong>
     Another thing to pay attention is that we should use bias delta value as state.
    </strong>
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    <strong>
     One last thing need to mention is how sufficient small $\delta \phi$ need to be so that we can use? equations below?
    </strong>
    $$
\begin{align}
Exp(\phi + \delta\phi) &amp;\approx Exp(\phi)Exp(J_r(\phi)\delta\phi) \\
Exp(\phi + J_r^{-1}(\phi)\delta\phi) &amp;\approx Exp(\phi)Exp(J_r(\phi)J_r^{-1}(\phi)\delta\phi) \\
Log(Exp(\phi)Exp(\delta\phi)) &amp;\approx \phi + J_r^{-1}(\phi)\delta\phi
\end{align}
$$
   </p>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [22]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1"># SO3 exponential approximation imports</span>

<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">expm</span><span class="p">,</span> <span class="n">logm</span>

<span class="k">def</span> <span class="nf">skew</span><span class="p">(</span><span class="n">omega</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">omega</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()],</span>
                     <span class="p">[</span><span class="n">omega</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">omega</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()],</span>
                     <span class="p">[</span><span class="o">-</span><span class="n">omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">omega</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="mi">0</span><span class="p">]])</span>

<span class="k">def</span> <span class="nf">unskew</span><span class="p">(</span><span class="n">Omega</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()],</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()],</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()]])</span>

<span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">omega</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">expm</span><span class="p">(</span><span class="n">skew</span><span class="p">(</span><span class="n">omega</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">unskew</span><span class="p">(</span><span class="n">logm</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">Adjoint_SO3</span><span class="p">(</span><span class="n">Omega</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Omega</span>

<span class="k">def</span> <span class="nf">LeftJacobian_SO3</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">skew</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">theta</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1"># Note: when theta is small, we should use taylor series</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">/</span><span class="n">theta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">A</span> <span class="o">+</span> <span class="p">((</span><span class="n">theta</span><span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">/</span><span class="n">theta</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>

<span class="c1">#def RightJacobian_SO3(w):</span>
<span class="c1">#    return Adjoint_SO3(expm(skew(-w))).dot(LeftJacobian_SO3(w))</span>

<span class="k">def</span> <span class="nf">RightJacobian_SO3</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">skew</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">theta</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1"># Note: when theta is small, we should use taylor series</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">/</span><span class="n">theta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">A</span> <span class="o">+</span> <span class="p">((</span><span class="n">theta</span><span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">/</span><span class="n">theta</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">RightJacobian_SO3_inv</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">skew</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">theta</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1"># Note: when theta is small, we should use taylor series</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">A</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">theta</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">from_rpy</span><span class="p">(</span><span class="n">roll</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">rotz</span><span class="p">(</span><span class="n">yaw</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">roty</span><span class="p">(</span><span class="n">pitch</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotx</span><span class="p">(</span><span class="n">roll</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">rotx</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                     <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">],</span>
                     <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]])</span>

<span class="k">def</span> <span class="nf">roty</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">],</span>
                     <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                     <span class="p">[</span><span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">]])</span>

<span class="k">def</span> <span class="nf">rotz</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                     <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                     <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing code_cell rendered">
 <div class="input">
  <div class="prompt input_prompt">
   In [ ]:
  </div>
  <div class="inner_cell">
   <div class="input_area collapsed">
    <div class="collapse_expand_button fa fa-1x fa-minus-square-o">
    </div>
    <div class="highlight hl-ipython3">
     <pre><span></span><span class="c1">## SO3 exponential approximation</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">small_value_magnitude</span> <span class="o">=</span> <span class="mf">1E-2</span>
<span class="k">def</span> <span class="nf">cal_exp_approximation_error</span><span class="p">(</span><span class="n">small_value_magnitude</span><span class="p">):</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">small_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">small_value_magnitude</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="n">small_w</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">RightJacobian_SO3</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">small_w</span><span class="p">)))))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'error norm: </span><span class="si">{</span><span class="n">cal_exp_approximation_error</span><span class="p">(</span><span class="n">small_value_magnitude</span><span class="p">)</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
<span class="c1">#</span>
</pre>
    </div>
   </div>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <p>
    Reference
   </p>
   <ul>
    <li>
     <a href="http://www.roboticsproceedings.org/rss11/p06.pdf">
      IMU Preintegration on Manifold for Efficient Visual-Inertial Maximum-a-Posteriori Estimation
     </a>
    </li>
   </ul>
  </div>
 </div>
</div>
<div class="cell border-box-sizing text_cell rendered">
 <div class="prompt input_prompt">
 </div>
 <div class="inner_cell">
  <div class="text_cell_render border-box-sizing rendered_html">
   <h3 id="Extended-Kalman-Filter-based-Filtering">
    Extended Kalman Filter based Filtering
    <a class="anchor-link" href="#Extended-Kalman-Filter-based-Filtering">
     ¶
    </a>
   </h3>
  </div>
 </div>
</div>

<div> This blog is converted from <a href="https://github.com/xipengwang/xipengwang.github.io/tree/master/notebooks/inertial-navigation-system.ipynb">inertial-navigation-system.ipynb</a></div>